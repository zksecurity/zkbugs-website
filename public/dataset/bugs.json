[
    {
        "Id": "lurk-lab/lurk-rs/inference_Multicase_number_of_defaults_not_enforced",
        "Path": "dataset/bellperson/lurk-lab/lurk-rs/inference_Multicase_number_of_defaults_not_enforced",
        "Project": "https://github.com/lurk-lab/lurk-rs",
        "Commit": "0x5c92c6a37856f43cb23bcfce59443da9d0ce0061",
        "Fix Commit": "edcda9760a66088db78f64994513fa19d67caa79",
        "DSL": "Bellperson",
        "Vulnerability": "Under-Constrained",
        "Impact": "Soundness",
        "Root Cause": "Wrong Translation of Logic into Constraints",
        "Reproduced": false,
        "Location": {
            "Path": "src/circuits",
            "Function": "apply_continuation",
            "Line": ""
        },
        "Source": {
            "Audit Report": {
                "Source Link": "https://github.com/zksecurity/zkbugs/blob/main/reports/documents/inference-lurk.pdf",
                "Bug ID": "Multicase number of defaults not enforced"
            }
        },
        "Commands": {
            "Setup Environment": "",
            "Reproduce": "",
            "Compile and Preprocess": "",
            "Positive Test": "",
            "Find Exploit": "",
            "Clean": ""
        },
        "Short Description of the Vulnerability": "The bug \"Multicase number of defaults not enforced\" refers to an issue in the 'apply_continuation()' function in Lurk's circuit logic, where it incorrectly sized the default argument for the 'multi_case' function. This misalignment resulted in some constraints not being properly enforced. The problem was rectified by supplying the correct number of arguments and adding an assertion to detect incorrect usage in the future.",
        "Short Description of the Exploit": "",
        "Proposed Mitigation": "The recommended fix for the bug 'Multicase number of defaults not enforced' is providing the correct number of arguments to the function and adding an assertion to detect incorrect usage in the future. This was implemented in commit edcda97.",
        "title": "Multicase number of defaults not enforced"
    },
    {
        "Id": "lurk-lab/lurk-rs/inference_Under-constrained_outputs_in_reduce_sym",
        "Path": "dataset/bellperson/lurk-lab/lurk-rs/inference_Under_constrained_outputs_in_reduce_sym",
        "Project": "https://github.com/lurk-lab/lurk-rs",
        "Commit": "0x5c92c6a37856f43cb23bcfce59443da9d0ce0061",
        "Fix Commit": "7236df555c2cfc7c37d290666d7d5167b3447032",
        "DSL": "Bellperson",
        "Vulnerability": "Under-Constrained",
        "Impact": "Soundness",
        "Root Cause": "Wrong Translation of Logic into Constraints",
        "Reproduced": false,
        "Location": {
            "Path": "src/circuits/reduce_sym.rs",
            "Function": "reduce_sym",
            "Line": ""
        },
        "Source": {
            "Audit Report": {
                "Source Link": "https://github.com/zksecurity/zkbugs/blob/main/reports/documents/inference-lurk.pdf",
                "Bug ID": "Under-constrained outputs in reduce_sym"
            }
        },
        "Commands": {
            "Setup Environment": "",
            "Reproduce": "",
            "Compile and Preprocess": "",
            "Positive Test": "",
            "Find Exploit": "",
            "Clean": ""
        },
        "Short Description of the Vulnerability": "The bug S-LRK-05 'Under-constrained outputs in reduce_sym' involves the reduction circuit not sufficiently constraining symbolic-expression outputs. Though the circuit is supposed to enforce outputs to be one of ten possible results, contingent on specific conditions, the constraints were initially weak or missing. This led to intermediate complexities, making the potential outcomes unconstrained under certain conditions. Upon review and refactoring, modifications were made to improve output constraints, enhance code clarity compared to specifications, and optimize the circuit design.",
        "Short Description of the Exploit": "",
        "Proposed Mitigation": "The recommended fix for the bug 'Under-constrained outputs in reduce_sym' involves refactoring the function `reduce_sym` into three parts: computing all branch conditions and possible output values, assigning predicates that are true when their value should be returned, and adding constraints to enforce the outputs. This refactoring makes the code more understandable and comparable to the Rust specification while reducing the total number of constraints.",
        "title": "Under-constrained outputs in reduce_sym"
    },
    {
        "Id": "lurk-lab/lurk-rs/inference_Soundness_failure_due_to_0_value_not_enforced",
        "Path": "dataset/bellperson/lurk-lab/lurk-rs/inference_Soundness_failure_due_to_0_value_not_enforced",
        "Project": "https://github.com/lurk-lab/lurk-rs",
        "Commit": "0x5c92c6a37856f43cb23bcfce59443da9d0ce0061",
        "Fix Commit": "",
        "DSL": "Bellperson",
        "Vulnerability": "Under-Constrained",
        "Impact": "Soundness",
        "Root Cause": "Assigned but Unconstrained",
        "Reproduced": false,
        "Location": {
            "Path": "src/circuits",
            "Function": "selector_dot_product",
            "Line": ""
        },
        "Source": {
            "Audit Report": {
                "Source Link": "https://github.com/zksecurity/zkbugs/blob/main/reports/documents/inference-lurk.pdf",
                "Bug ID": "Soundness failure due to 0 value not enforced"
            }
        },
        "Commands": {
            "Setup Environment": "",
            "Reproduce": "",
            "Compile and Preprocess": "",
            "Positive Test": "",
            "Find Exploit": "",
            "Clean": ""
        },
        "Short Description of the Vulnerability": "The bug \"Soundness failure due to 0 value not enforced\" occurred because the variable 'zero' in the selector_dot_product() function was allocated but not enforced to be zero. This variable was used as the default in pick(), allowing the final result to be manipulated. The issue was addressed in commit 4a61333 by passing a previously allocated zero variable from the global store, ensuring it remained unaltered throughout the operation.",
        "Short Description of the Exploit": "",
        "Proposed Mitigation": "The bug identified as 'Soundness failure due to 0 value not enforced' was fixed by passing a previously allocated zero variable from the global store to ensure it correctly enforces the zero value. This adjustment was made as recorded in commit 4a61333.",
        "title": "Soundness failure due to 0 value not enforced"
    },
    {
        "Id": "lurk-lab/lurk-rs/inference_Vectors_not_constrained_to_be_of_the_same_size",
        "Path": "dataset/bellperson/lurk-lab/lurk-rs/inference_Vectors_not_constrained_to_be_of_the_same_size",
        "Project": "https://github.com/lurk-lab/lurk-rs",
        "Commit": "0x5c92c6a37856f43cb23bcfce59443da9d0ce0061",
        "Fix Commit": "d2c7c69efec6b36dfcb55a0586c21df88f0a00b6",
        "DSL": "Bellperson",
        "Vulnerability": "Under-Constrained",
        "Impact": "Soundness",
        "Root Cause": "Wrong Translation of Logic into Constraints",
        "Reproduced": false,
        "Location": {
            "Path": "src/circuits",
            "Function": "multi_case",
            "Line": ""
        },
        "Source": {
            "Audit Report": {
                "Source Link": "https://github.com/zksecurity/zkbugs/blob/main/reports/documents/inference-lurk.pdf",
                "Bug ID": "Vectors not constrained to be of the same size"
            }
        },
        "Commands": {
            "Setup Environment": "",
            "Reproduce": "",
            "Compile and Preprocess": "",
            "Positive Test": "",
            "Find Exploit": "",
            "Clean": ""
        },
        "Short Description of the Vulnerability": "The bug titled \"Vectors not constrained to be of the same size\" involves vectors in Lurk's circuit operations not being enforced to match in size, leading to potential runtime crashes or uncaught bugs. Measures including adding assertions for size consistency have been implemented to address these issues and prevent potential soundness or runtime problems.",
        "Short Description of the Exploit": "",
        "Proposed Mitigation": "To fix the bug 'Vectors not constrained to be of the same size,' the recommended fix involves adding assertions in various functions to ensure vectors are the same size, preventing runtime crashes and uncaught bugs. This was implemented and validated through adjusted tests as per commit d2c7c69.",
        "title": "Vectors not constrained to be of the same size"
    },
    {
        "Id": "lurk-lab/lurk-rs/inference_Soundness_failure_due_toaccumulator_1_initial_value_not_enforced",
        "Path": "dataset/bellperson/lurk-lab/lurk-rs/inference_Soundness_failure_due_toaccumulator_1_initial_value_not_enforced",
        "Project": "https://github.com/lurk-lab/lurk-rs",
        "Commit": "0x5c92c6a37856f43cb23bcfce59443da9d0ce0061",
        "Fix Commit": "",
        "DSL": "Bellperson",
        "Vulnerability": "Under-Constrained",
        "Impact": "Soundness",
        "Root Cause": "Assigned but Unconstrained",
        "Reproduced": false,
        "Location": {
            "Path": "src/circuits/multi_case_aux",
            "Function": "multi_case_aux",
            "Line": ""
        },
        "Source": {
            "Audit Report": {
                "Source Link": "https://github.com/zksecurity/zkbugs/blob/main/reports/documents/inference-lurk.pdf",
                "Bug ID": "Soundness failure due toaccumulator 1 initial value not enforced"
            }
        },
        "Commands": {
            "Setup Environment": "",
            "Reproduce": "",
            "Compile and Preprocess": "",
            "Positive Test": "",
            "Find Exploit": "",
            "Clean": ""
        },
        "Short Description of the Vulnerability": "The bug \"Soundness failure due to accumulator 1 initial value not enforced\" occurs because in the function multi_case_aux, the initial accumulator variable 'acc' is set to 1 but this value is not enforced. As a result, changing this value to 0 could manipulate the variable '_selected' to always be true, affecting the soundness of the program. This issue was corrected in a code update that involved passing a global store as input and utilizing a previously allocated 'true_num' variable.",
        "Short Description of the Exploit": "",
        "Proposed Mitigation": "The recommended fix for the bug 'Soundness failure due to accumulator 1 initial value not enforced' is addressed by passing the global store as input and using the previously allocated true_num variable. This was implemented in commit 4a61333.",
        "title": "Soundness failure due toaccumulator 1 initial value not enforced"
    },
    {
        "Id": "lurk-lab/neptune/inference_Zero_padding_not_enforced",
        "Path": "dataset/bellperson/lurk-lab/neptune/inference_Zero_padding_not_enforced",
        "Project": "https://github.com/lurk-lab/neptune",
        "Commit": "0x5c92c6a37856f43cb23bcfce59443da9d0ce0061",
        "Fix Commit": "2415d641dcbdab17b3264d2254705a382c86ce73",
        "DSL": "Bellperson",
        "Vulnerability": "Under-Constrained",
        "Impact": "Soundness",
        "Root Cause": "Assigned but Unconstrained",
        "Reproduced": false,
        "Location": {
            "Path": "filecoin-project/neptune/src/circuit2.rs",
            "Function": "poseidon_hash_allocated",
            "Line": ""
        },
        "Source": {
            "Audit Report": {
                "Source Link": "https://github.com/zksecurity/zkbugs/blob/main/reports/documents/inference-lurk.pdf",
                "Bug ID": "Zero padding not enforced"
            }
        },
        "Commands": {
            "Setup Environment": "",
            "Reproduce": "",
            "Compile and Preprocess": "",
            "Positive Test": "",
            "Find Exploit": "",
            "Clean": ""
        },
        "Short Description of the Vulnerability": "The bug \"Zero padding not enforced\" refers to an issue in the function poseidon_hash_allocated() within the neptune library, where padding with newly allocated zero variables was not enforced to be zero in scenarios where hash_type is ConstantLength and the length is smaller than the arity. This flaw potentially allowed for hash manipulation that could still pass Poseidon validation checks. It was fixed by constraining the padding values to be zero using a new function enforce_zero().",
        "Short Description of the Exploit": "",
        "Proposed Mitigation": "The recommended fix for the bug \"Zero padding not enforced\" is to ensure that zero padding values are constrained to be zero, using the function `enforce_zero()`. This fix was implemented in commit 2415d64.",
        "title": "Zero padding not enforced"
    },
    {
        "Id": "filecoin-project/rust-fil-proofs/trapdoor_Add_missing_public_input_for_replica-id",
        "Path": "dataset/bellperson/filecoin-project/rust-fil-proofs/trapdoor_Add_missing_public_input_for_replica_id",
        "Project": "https://github.com/filecoin-project/rust-fil-proofs",
        "Commit": "8efe93",
        "Fix Commit": "a4c25bedaaa3099e89770d704ba3bee2cbec87c3fd7e4f5fabbcb1bce7aa9fce",
        "DSL": "Bellperson",
        "Vulnerability": "Under-Constrained",
        "Impact": "Soundness",
        "Root Cause": "Circuit Design Issue",
        "Reproduced": false,
        "Location": {
            "Path": "storage-proofs/src/porep/stacked/vanilla/challenges.rs",
            "Function": "derive_internal",
            "Line": ""
        },
        "Source": {
            "Audit Report": {
                "Source Link": "https://github.com/zksecurity/zkbugs/blob/main/reports/documents/trapdoor-filecoin-disclosure.pdf",
                "Bug ID": "Add missing public input for replica-id"
            }
        },
        "Commands": {
            "Setup Environment": "",
            "Reproduce": "",
            "Compile and Preprocess": "",
            "Positive Test": "",
            "Find Exploit": "",
            "Clean": ""
        },
        "Short Description of the Vulnerability": "The bug in PoREP V25 was that the \"replica_id\" was not included as a public input in the proof circuit. This omission allowed for the use of a forged \"replica_id\" in the SDR calculation process, meaning an attacker could pre-compute the SDR values using a fake \"replica_id\" and bypass the intended security mechanism. Consequently, this flaw could lead to the reuse of one SDR replica calculation across multiple sectors, fundamentally undermining the integrity of the system.",
        "Short Description of the Exploit": "",
        "Proposed Mitigation": "The recommended fix for the vulnerability is to include the replica_id as a public input in the PoREP circuit to ensure that the SDR calculation is legitimately tied to a specified replica_id, not just any replica_id. This change would prevent the exploitation where one fixed replica_id could be used for calculations across different sectors.",
        "title": "Add missing public input for replica-id"
    },
    {
        "Id": "Consensys/gnark/Unsoundness_in_variable_comparison_/_non-unique_binary_decomposition",
        "Path": "dataset/gnark/Consensys/gnark/Unsoundness_in_variable_comparison__non_unique_binary_decomposition",
        "Project": "https://github.com/Consensys/gnark",
        "Commit": "",
        "Fix Commit": "",
        "DSL": "gnark",
        "Vulnerability": "Under-Constrained",
        "Impact": "Soundness",
        "Root Cause": "Missing Input Constraints",
        "Reproduced": false,
        "Location": {
            "Path": "",
            "Function": "",
            "Line": ""
        },
        "Source": {
            "Audit Report": {
                "Source Link": "https://github.com/Consensys/gnark/security/advisories/GHSA-498w-5j49-vqjg",
                "Bug ID": "Unsoundness in variable comparison / non-unique binary decomposition"
            }
        },
        "Commands": {
            "Setup Environment": "",
            "Reproduce": "",
            "Compile and Preprocess": "",
            "Positive Test": "",
            "Find Exploit": "",
            "Clean": ""
        },
        "Short Description of the Vulnerability": "",
        "Short Description of the Exploit": "",
        "Proposed Mitigation": "",
        "title": "Unsoundness in variable comparison / non-unique binary decomposition"
    },
    {
        "Id": "scroll-tech/poseidon-circuit/zellic_mpt_only_being_true_leads_to_overconstrained_circuits",
        "Path": "dataset/halo2/scroll-tech/poseidon-circuit/zellic_mpt_only_being_true_leads_to_overconstrained_circuits",
        "Project": "https://github.com/scroll-tech/poseidon-circuit",
        "Commit": "0xf3ebc6af0e5049d2f45259ef79741f9c7d7794e1",
        "Fix Commit": "912f5ed2c6cacd64a0006e868e3cb4b624acc019",
        "DSL": "Halo2",
        "Vulnerability": "Over-Constrained",
        "Impact": "Completeness",
        "Root Cause": "Other Programming Errors",
        "Reproduced": false,
        "Location": {
            "Path": "src/hash.rs",
            "Function": "",
            "Line": "11"
        },
        "Source": {
            "Audit Report": {
                "Source Link": "https://github.com/zksecurity/zkbugs/blob/main/reports/documents/zellic-scroll.pdf",
                "Bug ID": "mpt_only being true leads to overconstrained circuits"
            }
        },
        "Commands": {
            "Setup Environment": "",
            "Reproduce": "",
            "Compile and Preprocess": "",
            "Positive Test": "",
            "Find Exploit": "",
            "Clean": ""
        },
        "Short Description of the Vulnerability": "The bug regarding 'mpt_only' being true leads to overconstrained circuits in the Poseidon hashing implementation means that when the mpt_only flag is set to true, the circuit incorrectly constrains certain input values to zero. This results in any hashing attempts with non-zero inputs failing the ZKP verification, potentially limiting the functionality of the circuit. The issue arises from an incorrect ordering in the logic that enables the custom row within the circuit.",
        "Short Description of the Exploit": "",
        "Proposed Mitigation": "Change the order of the two logic statements related to mpt_only so that it correctly enables the custom gate logic. Specifically, update it as follows: if self.mpt_only { return Ok(1); } config.s_custom.enable(region, 1)?;",
        "title": "mpt_only being true leads to overconstrained circuits"
    },
    {
        "Id": "scroll-tech/zkevm-circuits/trailofbits_Nondeterministic_execution_of_ReturnDataCopyGadget_and_ErrorReturnDataOutOfBoundGadget",
        "Path": "dataset/halo2/scroll-tech/zkevm-circuits/trailofbits_Nondeterministic_execution_of_ReturnDataCopyGadget_and_ErrorReturnDataOutOfBoundGadget",
        "Project": "https://github.com/scroll-tech/zkevm-circuits",
        "Commit": "0xe8bcb23e1f303bd6e0dc52924b0ed85710b8a016",
        "Fix Commit": "48172be100d36c89256fd55337997a56ba26d711",
        "DSL": "Halo2",
        "Vulnerability": "Under-Constrained",
        "Impact": "Soundness",
        "Root Cause": "Wrong Translation of Logic into Constraints",
        "Reproduced": false,
        "Location": {
            "Path": "zkevm-circuits/src/evm_circuit/execution/returndatacopy.rs",
            "Function": "",
            "Line": "52"
        },
        "Source": {
            "Audit Report": {
                "Source Link": "https://github.com/zksecurity/zkbugs/blob/main/reports/documents/trailofbits-scroll.pdf",
                "Bug ID": "Nondeterministic execution of ReturnDataCopyGadget and ErrorReturnDataOutOfBoundGadget"
            }
        },
        "Commands": {
            "Setup Environment": "",
            "Reproduce": "",
            "Compile and Preprocess": "",
            "Positive Test": "",
            "Find Exploit": "",
            "Clean": ""
        },
        "Short Description of the Vulnerability": "The bug \"Nondeterministic execution of ReturnDataCopyGadget and ErrorReturnDataOutOfBoundGadget\" involves a failure in the constraints of the ReturnDataCopy opcode, allowing a malicious prover to execute the opcode even when in an error state with certain inputs. This can lead to a situation where the prover can arbitrarily choose to either successfully execute or halt, resulting in state divergence from the correct EVM execution. The recommendation is to implement constraints to ensure that successful execution states are disjoint from error execution states, safeguarding against exploitation.",
        "Short Description of the Exploit": "",
        "Proposed Mitigation": "To resolve the nondeterministic execution of the ReturnDataCopyGadget and ErrorReturnDataOutOfBoundGadget, add constraints to ensure that the successful execution state is disjoint from the error execution state, preventing a malicious prover from selecting either path during execution. Additionally, investigate other error states to guarantee their disjoint nature with associated opcode implementations.",
        "title": "Nondeterministic execution of ReturnDataCopyGadget and ErrorReturnDataOutOfBoundGadget"
    },
    {
        "Id": "scroll-tech/zkevm-circuits/zellic_Highest_tx_id_must_be_equal_to_cum_num_txs_in_Tx_Circuit",
        "Path": "dataset/halo2/scroll-tech/zkevm-circuits/zellic_Highest_tx_id_must_be_equal_to_cum_num_txs_in_Tx_Circuit",
        "Project": "https://github.com/scroll-tech/zkevm-circuits",
        "Commit": "0x25dd32aa316ec842ffe79bb8efe9f05f86edc33e",
        "Fix Commit": "2e422878e0d78f769e08f0b1ad1275ee039362d5",
        "DSL": "Halo2",
        "Vulnerability": "Under-Constrained",
        "Impact": "Soundness",
        "Root Cause": "Misimplementation of a Specification",
        "Reproduced": false,
        "Location": {
            "Path": "TxCircuit/tx_circuit.rs",
            "Function": "",
            "Line": "66"
        },
        "Source": {
            "Audit Report": {
                "Source Link": "https://github.com/zksecurity/zkbugs/blob/main/reports/documents/zellic-scroll-2.pdf",
                "Bug ID": "Highest tx_id must be equal to cum_num_txs in Tx Circuit"
            }
        },
        "Commands": {
            "Setup Environment": "",
            "Reproduce": "",
            "Compile and Preprocess": "",
            "Positive Test": "",
            "Find Exploit": "",
            "Clean": ""
        },
        "Short Description of the Vulnerability": "The bug 'Highest tx_id must be equal to cum_num_txs in Tx Circuit' indicates that in the Tx Circuit, while there is a check to ensure that tx_id is less than the cum_num_txs, there isn't a constraint enforcing that the highest tx_id must be equal to cum_num_txs. This could allow cum_num_txs to be much larger than the actual set of tx_ids, potentially leading to inconsistencies in transaction processing. It is recommended to add a constraint to verify that the last non-padding transaction's tx_id equates to cum_num_txs.",
        "Short Description of the Exploit": "",
        "Proposed Mitigation": "Add a constraint to ensure that the tx_id of the last non-padding transaction in the Tx Circuit is equal to cum_num_txs.",
        "title": "Highest tx_id must be equal to cum_num_txs in Tx Circuit"
    },
    {
        "Id": "scroll-tech/zkevm-circuits/zellic_Missing_check_in_the_initialization_on_the_state_machine_in_RLP_Circuit",
        "Path": "dataset/halo2/scroll-tech/zkevm-circuits/zellic_Missing_check_in_the_initialization_on_the_state_machine_in_RLP_Circuit",
        "Project": "https://github.com/scroll-tech/zkevm-circuits",
        "Commit": "0x25dd32aa316ec842ffe79bb8efe9f05f86edc33e",
        "Fix Commit": "2e422878e0d78f769e08f0b1ad1275ee039362d5",
        "DSL": "Halo2",
        "Vulnerability": "Under-Constrained",
        "Impact": "Soundness",
        "Root Cause": "Missing Input Constraints",
        "Reproduced": false,
        "Location": {
            "Path": "rlp_circuit_fsm.rs",
            "Function": "",
            "Line": "19"
        },
        "Source": {
            "Audit Report": {
                "Source Link": "https://github.com/zksecurity/zkbugs/blob/main/reports/documents/zellic-scroll-2.pdf",
                "Bug ID": "Missing check in the initialization on the state machine in RLP Circuit"
            }
        },
        "Commands": {
            "Setup Environment": "",
            "Reproduce": "",
            "Compile and Preprocess": "",
            "Positive Test": "",
            "Find Exploit": "",
            "Clean": ""
        },
        "Short Description of the Vulnerability": "The bug report identifies a critical issue in the RLP Circuit related to the state machine initialization, specifically a missing check that should ensure the initial state is set to \"DecodeTagStart\" and the initial transaction ID is set to 1. This oversight may allow the state machine to start decoding incorrectly, potentially leading to invalid RLP decodings. The issue has been acknowledged and a fix has been implemented.",
        "Short Description of the Exploit": "",
        "Proposed Mitigation": "Add a check to ensure that the initial state of the state machine in the RLP Circuit is set to DecodeTagStart and that the initial tx_id is 1.",
        "title": "Missing check in the initialization on the state machine in RLP Circuit"
    },
    {
        "Id": "scroll-tech/zkevm-circuits/zellic_Missing_constraint_for_the_first_tx_id_in_Tx_Circuit",
        "Path": "dataset/halo2/scroll-tech/zkevm-circuits/zellic_Missing_constraint_for_the_first_tx_id_in_Tx_Circuit",
        "Project": "https://github.com/scroll-tech/zkevm-circuits",
        "Commit": "0x25dd32aa316ec842ffe79bb8efe9f05f86edc33e",
        "Fix Commit": "2e422878e0d78f769e08f0b1ad1275ee039362d5",
        "DSL": "Halo2",
        "Vulnerability": "Under-Constrained",
        "Impact": "Soundness",
        "Root Cause": "Missing Input Constraints",
        "Reproduced": false,
        "Location": {
            "Path": "TxCircuit",
            "Function": "",
            "Line": "40"
        },
        "Source": {
            "Audit Report": {
                "Source Link": "https://github.com/zksecurity/zkbugs/blob/main/reports/documents/zellic-scroll-2.pdf",
                "Bug ID": "Missing constraint for the first tx_id in Tx Circuit"
            }
        },
        "Commands": {
            "Setup Environment": "",
            "Reproduce": "",
            "Compile and Preprocess": "",
            "Positive Test": "",
            "Find Exploit": "",
            "Clean": ""
        },
        "Short Description of the Vulnerability": "The bug \"Missing constraint for the first tx_id in Tx Circuit\" refers to the absence of a check ensuring that the initial transaction ID (tx_id) starts at 1 in the Tx Circuit. While the transitions for tx_id have been implemented correctly, there is currently no enforcement that establishes the first tx_id as equal to 1, potentially allowing it to begin at any arbitrary value. It has been recommended to add this constraint to guarantee that the first tx_id is consistently set to 1.",
        "Short Description of the Exploit": "",
        "Proposed Mitigation": "Add a constraint to check that the first tx_id is equal to 1 in the Tx Circuit. Remediation has already been acknowledged and implemented by Scroll in commit 2e422878.",
        "title": "Missing constraint for the first tx_id in Tx Circuit"
    },
    {
        "Id": "scroll-tech/zkevm-circuits/trailofbits_The_“invalid_creation”_error_handling_circuit_is_unconstrained",
        "Path": "dataset/halo2/scroll-tech/zkevm-circuits/trailofbits_The_invalid_creation_error_handling_circuit_is_unconstrained",
        "Project": "https://github.com/scroll-tech/zkevm-circuits",
        "Commit": "0xfc6c8a2972870e62e96cde480b3aa48c0cc1303d",
        "Fix Commit": "799450ce1434270c27e98916817935586369d8c8",
        "DSL": "Halo2",
        "Vulnerability": "Under-Constrained",
        "Impact": "Soundness",
        "Root Cause": "Wrong Translation of Logic into Constraints",
        "Reproduced": false,
        "Location": {
            "Path": "evm_circuit/execution/error_invalid_creation_code.rs",
            "Function": "",
            "Line": "36"
        },
        "Source": {
            "Audit Report": {
                "Source Link": "https://github.com/zksecurity/zkbugs/blob/main/reports/documents/trailofbits-scroll-2.pdf",
                "Bug ID": "The “invalid creation” error handling circuit is unconstrained"
            }
        },
        "Commands": {
            "Setup Environment": "",
            "Reproduce": "",
            "Compile and Preprocess": "",
            "Positive Test": "",
            "Find Exploit": "",
            "Clean": ""
        },
        "Short Description of the Vulnerability": "The \"invalid creation\" error handling circuit is unconstrained, which means it does not enforce the expected condition that the first byte of the actual memory should be 0xef. This lack of constraint allows a malicious prover to redirect EVM execution to a halt state after the CREATE opcode is executed, enabling potential exploitation. Immediate action is needed to bind the first byte witness to the relevant memory value to prevent this issue.",
        "Short Description of the Exploit": "",
        "Proposed Mitigation": "Short-term, bind the first_byte witness value to the memory value to ensure it equals 0xef after the CREATE opcode is called. Long-term, generate malicious traces to add to the test suite for soundness verification whenever an issue is found.",
        "title": "The “invalid creation” error handling circuit is unconstrained"
    },
    {
        "Id": "scroll-tech/zkevm-circuits/zellic_ChainId_is_not_mapped_to_it’s_corresponding_RLP_Tag_in_Tx_Circuit",
        "Path": "dataset/halo2/scroll-tech/zkevm-circuits/zellic_ChainId_is_not_mapped_to_its_corresponding_RLP_Tag_in_Tx_Circuit",
        "Project": "https://github.com/scroll-tech/zkevm-circuits",
        "Commit": "0x25dd32aa316ec842ffe79bb8efe9f05f86edc33e",
        "Fix Commit": "2e422878e0d78f769e08f0b1ad1275ee039362d5",
        "DSL": "Halo2",
        "Vulnerability": "Under-Constrained",
        "Impact": "Soundness",
        "Root Cause": "Missing Input Constraints",
        "Reproduced": false,
        "Location": {
            "Path": "TxCircuit/tx_circuit.rs",
            "Function": "",
            "Line": "64"
        },
        "Source": {
            "Audit Report": {
                "Source Link": "https://github.com/zksecurity/zkbugs/blob/main/reports/documents/zellic-scroll-2.pdf",
                "Bug ID": "ChainId is not mapped to it’s corresponding RLP Tag in Tx Circuit"
            }
        },
        "Commands": {
            "Setup Environment": "",
            "Reproduce": "",
            "Compile and Preprocess": "",
            "Positive Test": "",
            "Find Exploit": "",
            "Clean": ""
        },
        "Short Description of the Vulnerability": "The bug 'ChainId is not mapped to its corresponding RLP Tag in Tx Circuit' indicates that within the Tx Circuit, the ChainId field is incorrectly set to Null in the mapping of TxFieldTag values. This oversight means that the ChainId is omitted during lookups needed for verifying transaction signatures, potentially allowing a scenario where the ChainId value could be neglected for transaction signatures. It is recommended to add the appropriate mapping and ensure ChainId is included in RLP lookups.",
        "Short Description of the Exploit": "",
        "Proposed Mitigation": "Recommend adding the mapping from TxFieldTag: ChainID to the RLPTag: ChainId and ensure the ChainID value in the TxTable is looked up in the RLPTable using this mapping.",
        "title": "ChainId is not mapped to it’s corresponding RLP Tag in Tx Circuit"
    },
    {
        "Id": "scroll-tech/zkevm-circuits/zellic_Missing_do_not_emit!_constraints",
        "Path": "dataset/halo2/scroll-tech/zkevm-circuits/zellic_Missing_do_not_emit!_constraints",
        "Project": "https://github.com/scroll-tech/zkevm-circuits",
        "Commit": "0x25dd32aa316ec842ffe79bb8efe9f05f86edc33e",
        "Fix Commit": "2e422878e0d78f769e08f0b1ad1275ee039362d5",
        "DSL": "Halo2",
        "Vulnerability": "Under-Constrained",
        "Impact": "Soundness",
        "Root Cause": "Wrong Translation of Logic into Constraints",
        "Reproduced": false,
        "Location": {
            "Path": "rlp_circuit_fsm.rs",
            "Function": "",
            "Line": "25"
        },
        "Source": {
            "Audit Report": {
                "Source Link": "https://github.com/zksecurity/zkbugs/blob/main/reports/documents/zellic-scroll-2.pdf",
                "Bug ID": "Missing do_not_emit! constraints"
            }
        },
        "Commands": {
            "Setup Environment": "",
            "Reproduce": "",
            "Compile and Preprocess": "",
            "Positive Test": "",
            "Find Exploit": "",
            "Clean": ""
        },
        "Short Description of the Vulnerability": "The bug 'Missing do_not_emit! constraints' refers to the absence of necessary constraints in the RLP circuit's state transition from DecodeTagStart to LongList. Specifically, the do_not_emit! macro, which ensures that the output is marked as false for rows not representing a complete tag value, is not applied in this transition. This oversight can lead to the RlpFsmRlpTable having invalid rows with output incorrectly set to true, posing a critical security risk.",
        "Short Description of the Exploit": "",
        "Proposed Mitigation": "Add the missing `do_not_emit!` constraints in the `DecodeTagStart => LongList` transition to ensure that `is_output` is set to false for rows that do not represent a full tag value.",
        "title": "Missing do_not_emit! constraints"
    },
    {
        "Id": "scroll-tech/zkevm-circuits/trailofbits_Underconstrained_warm_status_on_CALL_opcodes_allows_gas_cost_forgery",
        "Path": "dataset/halo2/scroll-tech/zkevm-circuits/trailofbits_Underconstrained_warm_status_on_CALL_opcodes_allows_gas_cost_forgery",
        "Project": "https://github.com/scroll-tech/zkevm-circuits",
        "Commit": "0xe8bcb23e1f303bd6e0dc52924b0ed85710b8a016",
        "Fix Commit": "e72a6a818cbda6c14cb551573432e59fe61ce109345dd4c088508a60c27979af",
        "DSL": "Halo2",
        "Vulnerability": "Under-Constrained",
        "Impact": "Soundness",
        "Root Cause": "Assigned but Unconstrained",
        "Reproduced": false,
        "Location": {
            "Path": "zkevm-circuits/src/evm_circuit/execution/callop.rs",
            "Function": "",
            "Line": "129-138"
        },
        "Source": {
            "Audit Report": {
                "Source Link": "https://github.com/zksecurity/zkbugs/blob/main/reports/documents/trailofbits-scroll.pdf",
                "Bug ID": "Underconstrained warm status on CALL opcodes allows gas cost forgery"
            }
        },
        "Commands": {
            "Setup Environment": "",
            "Reproduce": "",
            "Compile and Preprocess": "",
            "Positive Test": "",
            "Find Exploit": "",
            "Clean": ""
        },
        "Short Description of the Vulnerability": "The bug 'Underconstrained warm status on CALL opcodes allows gas cost forgery' highlights a vulnerability in the zkevm-circuits where a malicious prover can manipulate the status of an address (cold or warm) during the execution of CALL-like opcodes. This allows the prover to set an address as cold erroneously, which leads to incorrect gas cost calculations for subsequent calls, potentially resulting in state divergence and financial losses. The recommendation is to add constraints to ensure that the address becomes warm as required by the EVM specification.",
        "Short Description of the Exploit": "",
        "Proposed Mitigation": "Add constraints to ensure that the callee address becomes warm on the CALL opcodes by constraining the variable controlling the warm status to true. Additionally, ensure initial values for access list reads reflect correct warm status as specified in the EVM documentation.",
        "title": "Underconstrained warm status on CALL opcodes allows gas cost forgery"
    },
    {
        "Id": "scroll-tech/zkevm-circuits/trailofbits_ModGadget_is_underconstrained_and_allows_incorrect_MULMOD_operations_to_be_proven",
        "Path": "dataset/halo2/scroll-tech/zkevm-circuits/trailofbits_ModGadget_is_underconstrained_and_allows_incorrect_MULMOD_operations_to_be_proven",
        "Project": "https://github.com/scroll-tech/zkevm-circuits",
        "Commit": "0xe8bcb23e1f303bd6e0dc52924b0ed85710b8a016",
        "Fix Commit": "069477d3efd1b4fb19640ff1d9dcd4fb3e3c9e5f3adc646e1bfc7ad0f07a0162",
        "DSL": "Halo2",
        "Vulnerability": "Under-Constrained",
        "Impact": "Soundness",
        "Root Cause": "Wrong Translation of Logic into Constraints",
        "Reproduced": false,
        "Location": {
            "Path": "zkevm-circuits/src/evm_circuit/util/math_gadget/modulo.rs",
            "Function": "construct",
            "Line": "10-44"
        },
        "Source": {
            "Audit Report": {
                "Source Link": "https://github.com/zksecurity/zkbugs/blob/main/reports/documents/trailofbits-scroll.pdf",
                "Bug ID": "ModGadget is underconstrained and allows incorrect MULMOD operations to be proven"
            }
        },
        "Commands": {
            "Setup Environment": "",
            "Reproduce": "",
            "Compile and Preprocess": "",
            "Positive Test": "",
            "Find Exploit": "",
            "Clean": ""
        },
        "Short Description of the Vulnerability": "The bug report indicates that the ModGadget circuit is underconstrained, allowing incorrect MULMOD operations to be proven. Specifically, when dividing by zero, it incorrectly permits a proof that a * b mod 0 equals a * b, contrary to the EVM specifications which dictate that the result should be zero. This vulnerability could be exploited to achieve state divergence and potentially result in financial loss.",
        "Short Description of the Exploit": "",
        "Proposed Mitigation": "To fix the issue with 'ModGadget being underconstrained and allowing incorrect MULMOD operations,' update the constraint for the variable `a_or_zero` to be correctly conditioned on the value of `n`. The revised constraint should ensure that `a_or_zero` is only set to `a` when `n` is not zero, and must equal zero when `n` is zero.",
        "title": "ModGadget is underconstrained and allows incorrect MULMOD operations to be proven"
    },
    {
        "Id": "scroll-tech/zkevm-circuits/zellic_The_CallDataRLC_value_in_the_fixed_assignments_is_not_validated_against_the_actual_calldata_in_Tx_Circuit",
        "Path": "dataset/halo2/scroll-tech/zkevm-circuits/zellic_The_CallDataRLC_value_in_the_fixed_assignments_is_not_validated_against_the_actual_calldata_in_Tx_Circuit",
        "Project": "https://github.com/scroll-tech/zkevm-circuits",
        "Commit": "0x25dd32aa316ec842ffe79bb8efe9f05f86edc33e",
        "Fix Commit": "2e422878e0d78f769e08f0b1ad1275ee039362d5",
        "DSL": "Halo2",
        "Vulnerability": "Under-Constrained",
        "Impact": "Soundness",
        "Root Cause": "Assigned but Unconstrained",
        "Reproduced": false,
        "Location": {
            "Path": "TxCircuit",
            "Function": "",
            "Line": "42"
        },
        "Source": {
            "Audit Report": {
                "Source Link": "https://github.com/zksecurity/zkbugs/blob/main/reports/documents/zellic-scroll-2.pdf",
                "Bug ID": "The CallDataRLC value in the fixed assignments is not validated against the actual calldata in Tx Circuit"
            }
        },
        "Commands": {
            "Setup Environment": "",
            "Reproduce": "",
            "Compile and Preprocess": "",
            "Positive Test": "",
            "Find Exploit": "",
            "Clean": ""
        },
        "Short Description of the Vulnerability": "The bug refers to the lack of validation for the CallDataRLC value against the actual calldata in the Tx Circuit. This issue could lead to discrepancies where the calldata used may differ from what is expected, potentially undermining contract integrity. It has been identified as critical due to its high likelihood of occurrence.",
        "Short Description of the Exploit": "",
        "Proposed Mitigation": "The recommended fix for the bug regarding the CallDataRLC value is to add a check to ensure the consistency between the CallDataRLC and the calldata part of the Tx Circuit layout via a lookup argument.",
        "title": "The CallDataRLC value in the fixed assignments is not validated against the actual calldata in Tx Circuit"
    },
    {
        "Id": "scroll-tech/zkevm-circuits/zellic_The_first_row_of_each_Tx_in_the_calldata_section_is_undercon-_strained_in_Tx_Circuit",
        "Path": "dataset/halo2/scroll-tech/zkevm-circuits/zellic_The_first_row_of_each_Tx_in_the_calldata_section_is_undercon__strained_in_Tx_Circuit",
        "Project": "https://github.com/scroll-tech/zkevm-circuits",
        "Commit": "0x25dd32aa316ec842ffe79bb8efe9f05f86edc33e",
        "Fix Commit": "",
        "DSL": "Halo2",
        "Vulnerability": "Under-Constrained",
        "Impact": "Soundness",
        "Root Cause": "Wrong Translation of Logic into Constraints",
        "Reproduced": false,
        "Location": {
            "Path": "TxCircuit",
            "Function": "",
            "Line": "30"
        },
        "Source": {
            "Audit Report": {
                "Source Link": "https://github.com/zksecurity/zkbugs/blob/main/reports/documents/zellic-scroll-2.pdf",
                "Bug ID": "The first row of each Tx in the calldata section is undercon- strained in Tx Circuit"
            }
        },
        "Commands": {
            "Setup Environment": "",
            "Reproduce": "",
            "Compile and Preprocess": "",
            "Positive Test": "",
            "Find Exploit": "",
            "Clean": ""
        },
        "Short Description of the Vulnerability": "The bug described is that the first row of each transaction in the calldata section of the Tx Circuit is underconstrained, meaning there are no checks ensuring the starting index is 0 and appropriating the accurate initial calldata gas cost. This could allow the index and gas cost values to be manipulated, leading to incorrect data processing for transactions. Appropriate constraints should be added to rectify this issue.",
        "Short Description of the Exploit": "",
        "Proposed Mitigation": "The recommended fix for the bug \"The first row of each Tx in the calldata section is underconstrained in Tx Circuit\" is to add the necessary constraints for the first row to ensure that index = 0 and calldata_gas_cost_acc is set correctly based on the value of the first calldata byte. This would prevent malicious changes to the index and calldata_gas_cost for the first row of the transaction.",
        "title": "The first row of each Tx in the calldata section is undercon- strained in Tx Circuit"
    },
    {
        "Id": "scroll-tech/zkevm-circuits/zellic_Missing_range_checks_in_MulAdd_chip",
        "Path": "dataset/halo2/scroll-tech/zkevm-circuits/zellic_Missing_range_checks_in_MulAdd_chip",
        "Project": "https://github.com/scroll-tech/zkevm-circuits",
        "Commit": "0xf3ebc6af0e5049d2f45259ef79741f9c7d7794e1",
        "Fix Commit": "b20bed27e0a1b1345c125a2975875be555d2dff9",
        "DSL": "Halo2",
        "Vulnerability": "Under-Constrained",
        "Impact": "Soundness",
        "Root Cause": "Arithmetic Field Issues",
        "Reproduced": false,
        "Location": {
            "Path": "gadgets/src/mul_add.rs",
            "Function": "",
            "Line": "16"
        },
        "Source": {
            "Audit Report": {
                "Source Link": "https://github.com/zksecurity/zkbugs/blob/main/reports/documents/zellic-scroll.pdf",
                "Bug ID": "Missing range checks in MulAdd chip"
            }
        },
        "Commands": {
            "Setup Environment": "",
            "Reproduce": "",
            "Compile and Preprocess": "",
            "Positive Test": "",
            "Find Exploit": "",
            "Clean": ""
        },
        "Short Description of the Vulnerability": "The bug in the MulAdd chip relates to the absence of range checks for the individual elements used in calculations. Each element, such as 'a', 'b', 'c', and their associated limbs, must fall within specific ranges to ensure correct functionality; without these checks, the chip may accept incorrect values, potentially compromising the integrity of calculations. This issue has been classified as critical due to its potential impact on the overall functionality.",
        "Short Description of the Exploit": "",
        "Proposed Mitigation": "The recommended fix for the 'Missing range checks in MulAdd chip' bug is to use the RangeCheckGadget to constrain the elements used within the chip to their expected values, specifically ensuring that the limbs and carry elements are within specified ranges.",
        "title": "Missing range checks in MulAdd chip"
    },
    {
        "Id": "scroll-tech/zkevm-circuits/trailofbits_Incorrect_state_transitions_can_be_proven_for_any_chunk_by_manipulating_padding_flags",
        "Path": "dataset/halo2/scroll-tech/zkevm-circuits/trailofbits_Incorrect_state_transitions_can_be_proven_for_any_chunk_by_manipulating_padding_flags",
        "Project": "https://github.com/scroll-tech/zkevm-circuits",
        "Commit": "0xe40ab9e8e78fd362c50fcd0277db79a1c9a98e60",
        "Fix Commit": "138b7a3d7381932d02caef4462e47f7990c72b82",
        "DSL": "Halo2",
        "Vulnerability": "Under-Constrained",
        "Impact": "Soundness",
        "Root Cause": "Wrong Translation of Logic into Constraints",
        "Reproduced": false,
        "Location": {
            "Path": "aggregator/src/core.rs",
            "Function": "",
            "Line": "39"
        },
        "Source": {
            "Audit Report": {
                "Source Link": "https://github.com/zksecurity/zkbugs/blob/main/reports/documents/trailofbits-scroll-3.pdf",
                "Bug ID": "Incorrect state transitions can be proven for any chunk by manipulating padding flags"
            }
        },
        "Commands": {
            "Setup Environment": "",
            "Reproduce": "",
            "Compile and Preprocess": "",
            "Positive Test": "",
            "Find Exploit": "",
            "Clean": ""
        },
        "Short Description of the Vulnerability": "The bug regarding incorrect state transitions occurs because insufficient constraints in the aggregation circuit's padding logic allow malicious provers to create invalid proofs. Specifically, a malicious actor can manipulate padding flags to prove arbitrary state transitions or produce a proof for incorrect data transitions between chunks. This vulnerability poses a high severity risk as it could facilitate exploits that affect the integrity of state transitions within the zkEVM system.",
        "Short Description of the Exploit": "",
        "Proposed Mitigation": "Short-term, add constraints so that `num_valid_snarks` must be non-zero and `chunk_is_valid_cells` must not have any valid cells after padding chunks. Long-term, specify, review, and test all security-critical logic such as the aggregation padding validation thoroughly to ensure robustness against manipulation.",
        "title": "Incorrect state transitions can be proven for any chunk by manipulating padding flags"
    },
    {
        "Id": "scroll-tech/zkevm-circuits/zellic_padding_shift_is_underconstrained_in_the_bytecode_circuit",
        "Path": "dataset/halo2/scroll-tech/zkevm-circuits/zellic_padding_shift_is_underconstrained_in_the_bytecode_circuit",
        "Project": "https://github.com/scroll-tech/zkevm-circuits",
        "Commit": "0xf3ebc6af0e5049d2f45259ef79741f9c7d7794e1",
        "Fix Commit": "e8aecb68ccd87759dc4ea46e2cec9649a0803f5b",
        "DSL": "Halo2",
        "Vulnerability": "Under-Constrained",
        "Impact": "Soundness",
        "Root Cause": "Wrong Translation of Logic into Constraints",
        "Reproduced": false,
        "Location": {
            "Path": "zkevm-circuits/src/bytecode_circuit/to_poseidon_hash.rs",
            "Function": "",
            "Line": "13"
        },
        "Source": {
            "Audit Report": {
                "Source Link": "https://github.com/zksecurity/zkbugs/blob/main/reports/documents/zellic-scroll.pdf",
                "Bug ID": "padding_shift is underconstrained in the bytecode circuit"
            }
        },
        "Commands": {
            "Setup Environment": "",
            "Reproduce": "",
            "Compile and Preprocess": "",
            "Positive Test": "",
            "Find Exploit": "",
            "Clean": ""
        },
        "Short Description of the Vulnerability": "The bug \"padding_shift is underconstrained in the bytecode circuit\" indicates that the constraints related to the padding_shift variable are insufficient for the last byte of the bytecode. This can lead to incorrect field element generation in the Poseidon hash computation, allowing two different bytecodes to hash to the same field element. It is critical due to the potential for this under-constrained state to be exploited, and a recommendation was made to enhance the constraints for the last chunk of bytecode.",
        "Short Description of the Exploit": "",
        "Proposed Mitigation": "Add a constraint to the padding_shift for the last chunk of the bytecode to ensure it is set correctly, especially for cases where the bytecode length is not a multiple of 31. This will prevent different bytecodes from hashing to the same field element.",
        "title": "padding_shift is underconstrained in the bytecode circuit"
    },
    {
        "Id": "scroll-tech/zkevm-circuits/zellic_Equality_between_tag_value_and_the_final_tag_value_acc_not_checked",
        "Path": "dataset/halo2/scroll-tech/zkevm-circuits/zellic_Equality_between_tag_value_and_the_final_tag_value_acc_not_checked",
        "Project": "https://github.com/scroll-tech/zkevm-circuits",
        "Commit": "0x25dd32aa316ec842ffe79bb8efe9f05f86edc33e",
        "Fix Commit": "2e422878e0d78f769e08f0b1ad1275ee039362d5",
        "DSL": "Halo2",
        "Vulnerability": "Under-Constrained",
        "Impact": "Soundness",
        "Root Cause": "Assigned but Unconstrained",
        "Reproduced": false,
        "Location": {
            "Path": "RLPCircuit/rlp_circuit_fsm.rs",
            "Function": "",
            "Line": "23"
        },
        "Source": {
            "Audit Report": {
                "Source Link": "https://github.com/zksecurity/zkbugs/blob/main/reports/documents/zellic-scroll-2.pdf",
                "Bug ID": "Equality between tag_value and the final tag_value_acc not checked"
            }
        },
        "Commands": {
            "Setup Environment": "",
            "Reproduce": "",
            "Compile and Preprocess": "",
            "Positive Test": "",
            "Find Exploit": "",
            "Clean": ""
        },
        "Short Description of the Vulnerability": "The bug \"Equality between tag_value and the final tag_value_acc not checked\" refers to a missing validation in the RLP circuit's state machine during the transition from the Bytes state to the DecodeTagStart state. There is no condition to ensure that the accumulated tag value (tag_value_acc) equals the final tag value (tag_value) when the tag index equals the tag length, which could result in incorrect values being stored in the RLP table. The recommendation is to implement a check to validate that tag_value and tag_value_acc are equal.",
        "Short Description of the Exploit": "",
        "Proposed Mitigation": "Add a check to ensure that `tag_value` is equal to `tag_value_acc` before transitioning from the Bytes state to the DecodeTagStart state. This will verify that the accumulated tag value matches the expected value.",
        "title": "Equality between tag_value and the final tag_value_acc not checked"
    },
    {
        "Id": "scroll-tech/zkevm-circuits/zellic_Block_number_constraints_are_incorrect_in_PI_circuit",
        "Path": "dataset/halo2/scroll-tech/zkevm-circuits/zellic_Block_number_constraints_are_incorrect_in_PI_circuit",
        "Project": "https://github.com/scroll-tech/zkevm-circuits",
        "Commit": "0x25dd32aa316ec842ffe79bb8efe9f05f86edc33e",
        "Fix Commit": "",
        "DSL": "Halo2",
        "Vulnerability": "Under-Constrained",
        "Impact": "Soundness",
        "Root Cause": "Wrong Translation of Logic into Constraints",
        "Reproduced": false,
        "Location": {
            "Path": "PICircuit/pi_circuit.rs",
            "Function": "",
            "Line": "36"
        },
        "Source": {
            "Audit Report": {
                "Source Link": "https://github.com/zksecurity/zkbugs/blob/main/reports/documents/zellic-scroll-2.pdf",
                "Bug ID": "Block number constraints are incorrect in PI circuit"
            }
        },
        "Commands": {
            "Setup Environment": "",
            "Reproduce": "",
            "Compile and Preprocess": "",
            "Positive Test": "",
            "Find Exploit": "",
            "Clean": ""
        },
        "Short Description of the Vulnerability": "The bug \"Block number constraints are incorrect in PI circuit\" indicates that the index column for the block table, which is meant to correspond to block numbers, does not have properly enforced equality constraints. Specifically, the equality checks for the index values across rows are being executed incorrectly, allowing for potential discrepancies between the index and the actual block number. This flaw could lead to invalid results in the circuit that processes block numbers.",
        "Short Description of the Exploit": "",
        "Proposed Mitigation": "To fix the incorrect block number constraints in the PI circuit, the declarations for index_cells and block_number_cell, as well as the equality constraints, should be moved outside of the for loop that processes the table assignments. This ensures that the constraints are applied correctly to the entire block table.",
        "title": "Block number constraints are incorrect in PI circuit"
    },
    {
        "Id": "scroll-tech/zkevm-circuits/trailofbits_The_RlpU64Gadget_is_underconstrained_when_is_lt_128_is_false",
        "Path": "dataset/halo2/scroll-tech/zkevm-circuits/trailofbits_The_RlpU64Gadget_is_underconstrained_when_is_lt_128_is_false",
        "Project": "https://github.com/scroll-tech/zkevm-circuits",
        "Commit": "0xe8bcb23e1f303bd6e0dc52924b0ed85710b8a016",
        "Fix Commit": "2a69a55562336a54ce2b1a13748db7cf807c8e2a",
        "DSL": "Halo2",
        "Vulnerability": "Under-Constrained",
        "Impact": "Soundness",
        "Root Cause": "Wrong Translation of Logic into Constraints",
        "Reproduced": false,
        "Location": {
            "Path": "zkevm-circuits/src/evm_circuit/util/math_gadget/rlp.rs",
            "Function": "",
            "Line": "67"
        },
        "Source": {
            "Audit Report": {
                "Source Link": "https://github.com/zksecurity/zkbugs/blob/main/reports/documents/trailofbits-scroll.pdf",
                "Bug ID": "The RlpU64Gadget is underconstrained when is_lt_128 is false"
            }
        },
        "Commands": {
            "Setup Environment": "",
            "Reproduce": "",
            "Compile and Preprocess": "",
            "Positive Test": "",
            "Find Exploit": "",
            "Clean": ""
        },
        "Short Description of the Vulnerability": "The bug 'The RlpU64Gadget is underconstrained when is_lt_128 is false' indicates that the RlpU64Gadget circuit, which validates RLP-encoded values, lacks a constraint to ensure that when the is_lt_128 flag is false, the value is above 127. This oversight could allow a malicious prover to manipulate the value encoding, resulting in incorrect deserialization and potential state divergence in the zkEVM context. Recommendations include adding a constraint to verify that the value exceeds this threshold when is_lt_128 is false.",
        "Short Description of the Exploit": "",
        "Proposed Mitigation": "To fix the bug 'The RlpU64Gadget is underconstrained when is_lt_128 is false', add a constraint to ensure that the value is above 127 when is_lt_128 is false. Long-term, implement negative tests to ensure that mismatched witness values and is_lt_128 do not satisfy the circuit constraints.",
        "title": "The RlpU64Gadget is underconstrained when is_lt_128 is false"
    },
    {
        "Id": "scroll-tech/zkevm-circuits/zellic_Transition_to_new_RLP_instance_in_the_state_machine_is_un-_derconstrained_in_RLP_Circuit",
        "Path": "dataset/halo2/scroll-tech/zkevm-circuits/zellic_Transition_to_new_RLP_instance_in_the_state_machine_is_un__derconstrained_in_RLP_Circuit",
        "Project": "https://github.com/scroll-tech/zkevm-circuits",
        "Commit": "0x25dd32aa316ec842ffe79bb8efe9f05f86edc33e",
        "Fix Commit": "2e422878e0d78f769e08f0b1ad1275ee039362d5",
        "DSL": "Halo2",
        "Vulnerability": "Under-Constrained",
        "Impact": "Soundness",
        "Root Cause": "Wrong Translation of Logic into Constraints",
        "Reproduced": false,
        "Location": {
            "Path": "rlp_circuit_fsm.rs",
            "Function": "",
            "Line": "21"
        },
        "Source": {
            "Audit Report": {
                "Source Link": "https://github.com/zksecurity/zkbugs/blob/main/reports/documents/zellic-scroll-2.pdf",
                "Bug ID": "Transition to new RLP instance in the state machine is un- derconstrained in RLP Circuit"
            }
        },
        "Commands": {
            "Setup Environment": "",
            "Reproduce": "",
            "Compile and Preprocess": "",
            "Positive Test": "",
            "Find Exploit": "",
            "Clean": ""
        },
        "Short Description of the Vulnerability": "The bug regarding the \"Transition to new RLP instance in the state machine\" is that the constraints for transitioning between RLP instances are too lenient. Specifically, it allows cases like (tx_id', format') = (tx_id - 1, format + 1), which may lead to the same transaction appearing multiple times in the state machine. Proper checks need to be implemented to ensure valid transitions.",
        "Short Description of the Exploit": "",
        "Proposed Mitigation": "The recommended fix for the bug regarding the underconstraint of the transition to a new RLP instance in the state machine is to implement proper checks for the transition conditions, ensuring that (tx_id', format') cannot equal (tx_id - 1, format + 1) and that tag' must be either TxType or BeginList.",
        "title": "Transition to new RLP instance in the state machine is un- derconstrained in RLP Circuit"
    },
    {
        "Id": "scroll-tech/zkevm-circuits/zellic_Non-trivial_rotation_incorrectly_handled_in_ComparatorChip",
        "Path": "dataset/halo2/scroll-tech/zkevm-circuits/zellic_Non_trivial_rotation_incorrectly_handled_in_ComparatorChip",
        "Project": "https://github.com/scroll-tech/zkevm-circuits",
        "Commit": "0xf3ebc6af0e5049d2f45259ef79741f9c7d7794e1",
        "Fix Commit": "21f887d2ce44c4dc42c5ccae80c5ed94a6930954",
        "DSL": "Halo2",
        "Vulnerability": "Under-Constrained",
        "Impact": "Soundness",
        "Root Cause": "Unsafe Reuse of Circuit",
        "Reproduced": false,
        "Location": {
            "Path": "gadgets/src/comparator.rs",
            "Function": "",
            "Line": "25"
        },
        "Source": {
            "Audit Report": {
                "Source Link": "https://github.com/zksecurity/zkbugs/blob/main/reports/documents/zellic-scroll.pdf",
                "Bug ID": "Non-trivial rotation incorrectly handled in ComparatorChip"
            }
        },
        "Commands": {
            "Setup Environment": "",
            "Reproduce": "",
            "Compile and Preprocess": "",
            "Positive Test": "",
            "Find Exploit": "",
            "Clean": ""
        },
        "Short Description of the Vulnerability": "The bug 'Non-trivial rotation incorrectly handled in ComparatorChip' pertains to an issue in the implementation of comparison logic where the equality check does not account for rotation, leading to incorrect results during comparisons involving non-trivial rotations. This flaw can result in the generation of incorrect expressions in the circuit, potentially affecting circuit behavior. The recommendation is to either fix the comparison function or clearly document its limitations regarding rotations.",
        "Short Description of the Exploit": "",
        "Proposed Mitigation": "To fix the bug 'Non-trivial rotation incorrectly handled in ComparatorChip', the implementation of the `expr` function should be corrected to account for the rotation, or alternatively, it should be documented that the `eq_chip` result should not be used for a non-trivial rotation.",
        "title": "Non-trivial rotation incorrectly handled in ComparatorChip"
    },
    {
        "Id": "scroll-tech/zkevm-circuits/zellic_Multiple_RLP_encodings_share_the_same_RLC_value",
        "Path": "dataset/halo2/scroll-tech/zkevm-circuits/zellic_Multiple_RLP_encodings_share_the_same_RLC_value",
        "Project": "https://github.com/scroll-tech/zkevm-circuits",
        "Commit": "0x25dd32aa316ec842ffe79bb8efe9f05f86edc33e",
        "Fix Commit": "2e422878e0d78f769e08f0b1ad1275ee039362d5",
        "DSL": "Halo2",
        "Vulnerability": "Under-Constrained",
        "Impact": "Soundness",
        "Root Cause": "Wrong Translation of Logic into Constraints",
        "Reproduced": false,
        "Location": {
            "Path": "RLPCircuit/rlp_circuit_fsm.rs",
            "Function": "",
            "Line": "68"
        },
        "Source": {
            "Audit Report": {
                "Source Link": "https://github.com/zksecurity/zkbugs/blob/main/reports/documents/zellic-scroll-2.pdf",
                "Bug ID": "Multiple RLP encodings share the same RLC value"
            }
        },
        "Commands": {
            "Setup Environment": "",
            "Reproduce": "",
            "Compile and Preprocess": "",
            "Positive Test": "",
            "Find Exploit": "",
            "Clean": ""
        },
        "Short Description of the Vulnerability": "The bug report indicates that multiple RLP encodings can yield the same Random Linear Combination (RLC) value when using the formula for calculating RLC, as this formula does not account for the potential addition of arbitrary leading zeroes to an RLP tag. This creates a vulnerability where an attacker can prepend zero bytes to an encoded transaction without altering the calculated RLC value. The recommendation for mitigating this issue involves adding a separate column to track the length of the RLP tag, ensuring that the combination of RLC value and tag length remains unique.",
        "Short Description of the Exploit": "",
        "Proposed Mitigation": "The recommended fix for the bug \"Multiple RLP encodings share the same RLC value\" is to add an additional column, `tag_length`, which contains the number of bytes in an RLP tag, ensuring that the combination of `(bytes_rlc, tag_length)` will always correspond to unique RLP tags.",
        "title": "Multiple RLP encodings share the same RLC value"
    },
    {
        "Id": "scroll-tech/zkevm-circuits/zellic_The_sv_address_is_not_constrained_to_be_equal_throughout_a_single_transaction",
        "Path": "dataset/halo2/scroll-tech/zkevm-circuits/zellic_The_sv_address_is_not_constrained_to_be_equal_throughout_a_single_transaction",
        "Project": "https://github.com/scroll-tech/zkevm-circuits",
        "Commit": "0x25dd32aa316ec842ffe79bb8efe9f05f86edc33e",
        "Fix Commit": "2565e254fc7d42184aaade3d8ee144fdc79fdd10",
        "DSL": "Halo2",
        "Vulnerability": "Under-Constrained",
        "Impact": "Soundness",
        "Root Cause": "Wrong Translation of Logic into Constraints",
        "Reproduced": false,
        "Location": {
            "Path": "TxCircuit",
            "Function": "",
            "Line": "33"
        },
        "Source": {
            "Audit Report": {
                "Source Link": "https://github.com/zksecurity/zkbugs/blob/main/reports/documents/zellic-scroll-2.pdf",
                "Bug ID": "The sv_address is not constrained to be equal throughout a single transaction"
            }
        },
        "Commands": {
            "Setup Environment": "",
            "Reproduce": "",
            "Compile and Preprocess": "",
            "Positive Test": "",
            "Find Exploit": "",
            "Clean": ""
        },
        "Short Description of the Vulnerability": "The bug states that the sv_address in the transaction circuit is not consistently constrained to be the same throughout a single transaction. This leads to a situation where an attacker could use different addresses for the caller and the ECDSA signature, potentially allowing unauthorized contract calls. The recommendation is to implement a constraint ensuring that sv_address remains equal across all rows for the same transaction.",
        "Short Description of the Exploit": "",
        "Proposed Mitigation": "The recommended fix for the bug regarding 'sv_address' is to add checks to ensure that sv_address is equal throughout the rows representing the same transaction. This will prevent attackers from using different addresses for the caller and the ECDSA signature's recovered address.",
        "title": "The sv_address is not constrained to be equal throughout a single transaction"
    },
    {
        "Id": "scroll-tech/zkevm-circuits/zellic_The_state_machine_is_not_constrained_to_end_at_End",
        "Path": "dataset/halo2/scroll-tech/zkevm-circuits/zellic_The_state_machine_is_not_constrained_to_end_at_End",
        "Project": "https://github.com/scroll-tech/zkevm-circuits",
        "Commit": "0x25dd32aa316ec842ffe79bb8efe9f05f86edc33e",
        "Fix Commit": "2e422878e0d78f769e08f0b1ad1275ee039362d5",
        "DSL": "Halo2",
        "Vulnerability": "Under-Constrained",
        "Impact": "Soundness",
        "Root Cause": "Wrong Translation of Logic into Constraints",
        "Reproduced": false,
        "Location": {
            "Path": "RLPCircuit/rlp_circuit_fsm.rs",
            "Function": "",
            "Line": "27"
        },
        "Source": {
            "Audit Report": {
                "Source Link": "https://github.com/zksecurity/zkbugs/blob/main/reports/documents/zellic-scroll-2.pdf",
                "Bug ID": "The state machine is not constrained to end at End"
            }
        },
        "Commands": {
            "Setup Environment": "",
            "Reproduce": "",
            "Compile and Preprocess": "",
            "Positive Test": "",
            "Find Exploit": "",
            "Clean": ""
        },
        "Short Description of the Vulnerability": "The bug \"The state machine is not constrained to end at End\" indicates that there are no constraints preventing the state machine from concluding without reaching the End state. This lack of constraint could allow the machine to skip important checks related to gas costs and other calculations during the transaction processing, potentially compromising its integrity. The recommendation for remediation includes implementing a fixed column to ensure that the state is set to End when a certain condition is met, which has been acknowledged and fixed in a subsequent commit.",
        "Short Description of the Exploit": "",
        "Proposed Mitigation": "The recommended fix for the bug \"The state machine is not constrained to end at End\" is to add a fixed column q_last, implement the assign logic, and add the constraint that the state is End if q_last is enabled.",
        "title": "The state machine is not constrained to end at End"
    },
    {
        "Id": "scroll-tech/zkevm-circuits/zellic_Missing_range_check_for_byte_values_in_RLP_Circuit",
        "Path": "dataset/halo2/scroll-tech/zkevm-circuits/zellic_Missing_range_check_for_byte_values_in_RLP_Circuit",
        "Project": "https://github.com/scroll-tech/zkevm-circuits",
        "Commit": "0x25dd32aa316ec842ffe79bb8efe9f05f86edc33e",
        "Fix Commit": "2e422878e0d78f769e08f0b1ad1275ee039362d5",
        "DSL": "Halo2",
        "Vulnerability": "Under-Constrained",
        "Impact": "Soundness",
        "Root Cause": "Wrong Translation of Logic into Constraints",
        "Reproduced": false,
        "Location": {
            "Path": "rlp_circuit_fsm.rs",
            "Function": "",
            "Line": "14"
        },
        "Source": {
            "Audit Report": {
                "Source Link": "https://github.com/zksecurity/zkbugs/blob/main/reports/documents/zellic-scroll-2.pdf",
                "Bug ID": "Missing range check for byte values in RLP Circuit"
            }
        },
        "Commands": {
            "Setup Environment": "",
            "Reproduce": "",
            "Compile and Preprocess": "",
            "Positive Test": "",
            "Find Exploit": "",
            "Clean": ""
        },
        "Short Description of the Vulnerability": "The bug involves a missing range check for byte values in the RLP Circuit, specifically in the RLP circuit's data table, where the byte values are currently only validated for padding rows and not for actual data rows. This oversight allows byte values to potentially exceed the expected range of [0, 256), which can lead to incorrect behavior in the circuit. The issue has been identified as critical and has already been acknowledged by the Scroll team, with a fix implemented.",
        "Short Description of the Exploit": "",
        "Proposed Mitigation": "The recommended fix for the bug 'Missing range check for byte values in RLP Circuit' is to change the condition to ensure that the actual data rows' byte values are properly range-checked by modifying the check to exclude padding rows.",
        "title": "Missing range check for byte values in RLP Circuit"
    },
    {
        "Id": "scroll-tech/zkevm-circuits/zellic_ExpCircuit_has_a_under-constrained_exponentiation_algorithm_",
        "Path": "dataset/halo2/scroll-tech/zkevm-circuits/zellic_ExpCircuit_has_a_under_constrained_exponentiation_algorithm_",
        "Project": "https://github.com/scroll-tech/zkevm-circuits",
        "Commit": "0xf3ebc6af0e5049d2f45259ef79741f9c7d7794e1",
        "Fix Commit": "9b46ddbf01393ad845e48dea77de55b9358074da",
        "DSL": "Halo2",
        "Vulnerability": "Under-Constrained",
        "Impact": "Soundness",
        "Root Cause": "Wrong Translation of Logic into Constraints",
        "Reproduced": false,
        "Location": {
            "Path": "zkevm-circuits/src/exp-circuit.rs",
            "Function": "",
            "Line": "19"
        },
        "Source": {
            "Audit Report": {
                "Source Link": "https://github.com/zksecurity/zkbugs/blob/main/reports/documents/zellic-scroll.pdf",
                "Bug ID": "ExpCircuit has a under-constrained exponentiation algorithm "
            }
        },
        "Commands": {
            "Setup Environment": "",
            "Reproduce": "",
            "Compile and Preprocess": "",
            "Positive Test": "",
            "Find Exploit": "",
            "Clean": ""
        },
        "Short Description of the Vulnerability": "The bug in the ExpCircuit involves an under-constrained exponentiation algorithm where checks do not ensure that the appropriate conditions related to the exponent (specifically its parity) are met, potentially allowing incorrect calculations with malicious witness values. Although this issue does not compromise security or correctness directly, it affects the algorithm's efficiency and could lead to incorrect results in certain circumstances. A recommendation is made to add checks to verify that the first argument to the parity check is correct based on the exponent's value.",
        "Short Description of the Exploit": "",
        "Proposed Mitigation": "The recommended fix for the under-constrained exponentiation algorithm in ExpCircuit is to add a constraint to check that the first argument to the parity check MulAdd gadget is 2 when the parity is even (c=0).",
        "title": "ExpCircuit has a under-constrained exponentiation algorithm "
    },
    {
        "Id": "scroll-tech/zkevm-circuits/trailofbits_The_CREATE_and_CREATE2_opcodes_can_be_called_within_a_static_context",
        "Path": "dataset/halo2/scroll-tech/zkevm-circuits/trailofbits_The_CREATE_and_CREATE2_opcodes_can_be_called_within_a_static_context",
        "Project": "https://github.com/scroll-tech/zkevm-circuits",
        "Commit": "0xe8bcb23e1f303bd6e0dc52924b0ed85710b8a016",
        "Fix Commit": "66e8458ad6b55447e17de7f715e4395be943d682483be4a945b51f98a4cc50ae",
        "DSL": "Halo2",
        "Vulnerability": "Under-Constrained",
        "Impact": "Soundness",
        "Root Cause": "Misimplementation of a Specification",
        "Reproduced": false,
        "Location": {
            "Path": "zkevm-circuits/src/evm_circuit/execution/create.rs",
            "Function": "",
            "Line": "39"
        },
        "Source": {
            "Audit Report": {
                "Source Link": "https://github.com/zksecurity/zkbugs/blob/main/reports/documents/trailofbits-scroll.pdf",
                "Bug ID": "The CREATE and CREATE2 opcodes can be called within a static context"
            }
        },
        "Commands": {
            "Setup Environment": "",
            "Reproduce": "",
            "Compile and Preprocess": "",
            "Positive Test": "",
            "Find Exploit": "",
            "Clean": ""
        },
        "Short Description of the Vulnerability": "The bug involves the CREATE and CREATE2 opcodes being callable within a static context, which is not allowed according to the EVM specification. Currently, there are no constraints in place to prevent these state-changing operations from being executed when the context is static, potentially allowing for unintended state changes. This could enable malicious proofs leading to state divergence.",
        "Short Description of the Exploit": "",
        "Proposed Mitigation": "Add a constraint to the CREATE and CREATE2 opcodes to validate that they are not called within a static call context, ensuring compliance with EVM specifications that prohibit state-changing operations during static calls. Additionally, implement tests for these opcodes when invoked within a STATICCALL context.",
        "title": "The CREATE and CREATE2 opcodes can be called within a static context"
    },
    {
        "Id": "scroll-tech/zkevm-circuits/zellic_Missing_range_checks_for_the_LtChip",
        "Path": "dataset/halo2/scroll-tech/zkevm-circuits/zellic_Missing_range_checks_for_the_LtChip",
        "Project": "https://github.com/scroll-tech/zkevm-circuits",
        "Commit": "0x25dd32aa316ec842ffe79bb8efe9f05f86edc33e",
        "Fix Commit": "d0e7a07e8af25220623564ef1c3ed101ce63220e",
        "DSL": "Halo2",
        "Vulnerability": "Under-Constrained",
        "Impact": "Soundness",
        "Root Cause": "Missing Input Constraints",
        "Reproduced": false,
        "Location": {
            "Path": "RLPCircuit",
            "Function": "",
            "Line": "17"
        },
        "Source": {
            "Audit Report": {
                "Source Link": "https://github.com/zksecurity/zkbugs/blob/main/reports/documents/zellic-scroll-2.pdf",
                "Bug ID": "Missing range checks for the LtChip"
            }
        },
        "Commands": {
            "Setup Environment": "",
            "Reproduce": "",
            "Compile and Preprocess": "",
            "Positive Test": "",
            "Find Exploit": "",
            "Clean": ""
        },
        "Short Description of the Vulnerability": "The bug \"Missing range checks for the LtChip\" indicates that the LtChip is not ensuring that the difference columns fall within a specified byte range, which delegates this check to other circuits utilizing this chip. This oversight compromises the proper functionality of the LtChip, leading to potential failures in comparison operations within the relevant circuits. Recommendations include adding necessary range checks to ensure safe usage of the comparison gadgets.",
        "Short Description of the Exploit": "",
        "Proposed Mitigation": "Add the necessary range checks for the diff columns in the LtChip to ensure they are within the byte range, and implement checks in the TxCircuit to verify that tx_id and cum_num_txs are within specified limits.",
        "title": "Missing range checks for the LtChip"
    },
    {
        "Id": "scroll-tech/mpt-circuit/zellic_Missing_constraints_for_new_account_in_configure_balance",
        "Path": "dataset/halo2/scroll-tech/mpt-circuit/zellic_Missing_constraints_for_new_account_in_configure_balance",
        "Project": "https://github.com/scroll-tech/mpt-circuit",
        "Commit": "0x25dd32aa316ec842ffe79bb8efe9f05f86edc33e",
        "Fix Commit": "ef64eb52548946a0dd7f0ee83ce71ed8d460c405",
        "DSL": "Halo2",
        "Vulnerability": "Under-Constrained",
        "Impact": "Soundness",
        "Root Cause": "Assigned but Unconstrained",
        "Reproduced": false,
        "Location": {
            "Path": "MPTCircuit/gadgets/mpt_update.rs",
            "Function": "configure_balance",
            "Line": "53"
        },
        "Source": {
            "Audit Report": {
                "Source Link": "https://github.com/zksecurity/zkbugs/blob/main/reports/documents/zellic-scroll-2.pdf",
                "Bug ID": "Missing constraints for new account in configure_balance"
            }
        },
        "Commands": {
            "Setup Environment": "",
            "Reproduce": "",
            "Compile and Preprocess": "",
            "Positive Test": "",
            "Find Exploit": "",
            "Clean": ""
        },
        "Short Description of the Vulnerability": "The bug 'Missing constraints for new account in configure_balance' indicates that within the MPT circuit's configure_balance function, there is a lack of a required constraint that the sibling must equal zero when creating a new entry in the accounts trie and assigning the balance of the account. This omission may lead to soundness issues during the update of the balance for a new address. It is recommended to add a check to enforce that the sibling (nonce/codesize) is indeed equal to zero.",
        "Short Description of the Exploit": "",
        "Proposed Mitigation": "Add a constraint in the configure_balance function to ensure that the sibling is equal to 0 when the segment type is AccountLeaf3 and the path type is ExtensionNew. This will prevent potential soundness issues when updating the balance of a new address.",
        "title": "Missing constraints for new account in configure_balance"
    },
    {
        "Id": "scroll-tech/mpt-circuit/zellic_Incorrect_constraints_in_configure_nonce",
        "Path": "dataset/halo2/scroll-tech/mpt-circuit/zellic_Incorrect_constraints_in_configure_nonce",
        "Project": "https://github.com/scroll-tech/mpt-circuit",
        "Commit": "0x25dd32aa316ec842ffe79bb8efe9f05f86edc33e",
        "Fix Commit": "9aeff02e4d86e9bbecd0e420ebd3ed13a824e094",
        "DSL": "Halo2",
        "Vulnerability": "Under-Constrained",
        "Impact": "Soundness",
        "Root Cause": "Wrong Translation of Logic into Constraints",
        "Reproduced": false,
        "Location": {
            "Path": "MPTCircuit/gadgets/mpt_update.rs",
            "Function": "",
            "Line": "56"
        },
        "Source": {
            "Audit Report": {
                "Source Link": "https://github.com/zksecurity/zkbugs/blob/main/reports/documents/zellic-scroll-2.pdf",
                "Bug ID": "Incorrect constraints in configure_nonce"
            }
        },
        "Commands": {
            "Setup Environment": "",
            "Reproduce": "",
            "Compile and Preprocess": "",
            "Positive Test": "",
            "Find Exploit": "",
            "Clean": ""
        },
        "Short Description of the Vulnerability": "The bug \"Incorrect constraints in configure_nonce\" involves issues in the MPT circuit's configure_nonce function, where the checks for the new nonce size are incorrectly based on the old nonce value. This misconfiguration can lead to improper validations of nonce values, potentially allowing invalid nonces to be accepted, which may make accounts susceptible to denial-of-service attacks. The issue was acknowledged, and a fix has been implemented.",
        "Short Description of the Exploit": "",
        "Proposed Mitigation": "Fix the typos in the range check for the nonce in `configure_nonce` to correctly check the new nonce size instead of the old nonce when the segment type is AccountLeaf3 and the path type is Common, as well as addressing range checks for the new nonce in other conditions.",
        "title": "Incorrect constraints in configure_nonce"
    },
    {
        "Id": "scroll-tech/mpt-circuit/zellic_The_OneHot_encoding_gadget_has_incorrect_constraints",
        "Path": "dataset/halo2/scroll-tech/mpt-circuit/zellic_The_OneHot_encoding_gadget_has_incorrect_constraints",
        "Project": "https://github.com/scroll-tech/mpt-circuit",
        "Commit": "0x25dd32aa316ec842ffe79bb8efe9f05f86edc33e",
        "Fix Commit": "9bd18782c19b5f5b2a2410b80f1ace6cd9637dcb",
        "DSL": "Halo2",
        "Vulnerability": "Under-Constrained",
        "Impact": "Soundness",
        "Root Cause": "Incorrect Custom Gates",
        "Reproduced": false,
        "Location": {
            "Path": "MPTCircuit",
            "Function": "",
            "Line": "43"
        },
        "Source": {
            "Audit Report": {
                "Source Link": "https://github.com/zksecurity/zkbugs/blob/main/reports/documents/zellic-scroll-2.pdf",
                "Bug ID": "The OneHot encoding gadget has incorrect constraints"
            }
        },
        "Commands": {
            "Setup Environment": "",
            "Reproduce": "",
            "Compile and Preprocess": "",
            "Positive Test": "",
            "Find Exploit": "",
            "Clean": ""
        },
        "Short Description of the Vulnerability": "The bug in the OneHot encoding gadget involves incorrect constraints due to a helper function that mistakenly queries the current row's binary columns instead of the previous row's values. This flaw can lead to the generation of invalid proofs in the MPT (Merkle Patricia Tree) Circuit. A fix has been acknowledged and implemented by Scroll to address this issue.",
        "Short Description of the Exploit": "",
        "Proposed Mitigation": "The OneHot encoding gadget has incorrect constraints due to querying the value of the binary columns representing the one-hot encoding at the current row instead of the previous row. It is recommended to fix this by using BinaryColumn::previous to query the previous row.",
        "title": "The OneHot encoding gadget has incorrect constraints"
    },
    {
        "Id": "scroll-tech/mpt-circuit/trailofbits_The_NonceChanged_configuration_circuit_does_not_constrain_the_new_value_nonce_value",
        "Path": "dataset/halo2/scroll-tech/mpt-circuit/trailofbits_The_NonceChanged_configuration_circuit_does_not_constrain_the_new_value_nonce_value",
        "Project": "https://github.com/scroll-tech/mpt-circuit",
        "Commit": "0xfc6c8a2972870e62e96cde480b3aa48c0cc1303d",
        "Fix Commit": "",
        "DSL": "Halo2",
        "Vulnerability": "Under-Constrained",
        "Impact": "Soundness",
        "Root Cause": "Wrong Translation of Logic into Constraints",
        "Reproduced": false,
        "Location": {
            "Path": "src/gadgets/mpt_update.rs",
            "Function": "",
            "Line": "1209"
        },
        "Source": {
            "Audit Report": {
                "Source Link": "https://github.com/zksecurity/zkbugs/blob/main/reports/documents/trailofbits-scroll-2.pdf",
                "Bug ID": "The NonceChanged configuration circuit does not constrain the new value nonce value"
            }
        },
        "Commands": {
            "Setup Environment": "",
            "Reproduce": "",
            "Compile and Preprocess": "",
            "Positive Test": "",
            "Find Exploit": "",
            "Clean": ""
        },
        "Short Description of the Vulnerability": "The bug pertains to the NonceChanged configuration circuit, which fails to impose constraints on the new nonce value, allowing for it to be of arbitrary length. This oversight could lead to a malicious prover updating the account node with a nonce value that exceeds the expected 8 bytes, compromising system integrity. The issue is classified as high severity due to the potential for exploitation.",
        "Short Description of the Exploit": "",
        "Proposed Mitigation": "To fix the bug where the NonceChanged configuration circuit does not constrain the new value nonce, enforce a single unconditional constraint for the config.new_value instead of the erroneous references to config.old_value. Additionally, implement negative testing to ensure that values exceeding 8 bytes cannot be set for the nonce.",
        "title": "The NonceChanged configuration circuit does not constrain the new value nonce value"
    },
    {
        "Id": "scroll-tech/mpt-circuit/zellic_Missing_constraints_in_configure_empty_storage",
        "Path": "dataset/halo2/scroll-tech/mpt-circuit/zellic_Missing_constraints_in_configure_empty_storage",
        "Project": "https://github.com/scroll-tech/mpt-circuit",
        "Commit": "0x25dd32aa316ec842ffe79bb8efe9f05f86edc33e",
        "Fix Commit": "3ab166a4a62329ec42d44cd63fc9563ff29dea4e",
        "DSL": "Halo2",
        "Vulnerability": "Under-Constrained",
        "Impact": "Soundness",
        "Root Cause": "Wrong Translation of Logic into Constraints",
        "Reproduced": false,
        "Location": {
            "Path": "MPTCircuit/gadgets/mpt_update.rs",
            "Function": "",
            "Line": "54"
        },
        "Source": {
            "Audit Report": {
                "Source Link": "https://github.com/zksecurity/zkbugs/blob/main/reports/documents/zellic-scroll-2.pdf",
                "Bug ID": "Missing constraints in configure_empty_storage"
            }
        },
        "Commands": {
            "Setup Environment": "",
            "Reproduce": "",
            "Compile and Preprocess": "",
            "Positive Test": "",
            "Find Exploit": "",
            "Clean": ""
        },
        "Short Description of the Vulnerability": "The bug \"Missing constraints in configure_empty_storage\" refers to the absence of a check ensuring that the old and new hashes are identical for empty storage entries in the MPT circuit. This is similar to the existing constraints in the \"configure_empty_account\" function, which ensures the same condition is met. Without this check, there could be soundness issues when proving the non-existence of storage.",
        "Short Description of the Exploit": "",
        "Proposed Mitigation": "To fix the missing constraints in `configure_empty_storage`, ensure that the old_hash and new_hash are equal for an empty storage entry, similar to the existing check in `configure_empty_account`. Adding this check will help avoid soundness issues when proving that storage does not exist.",
        "title": "Missing constraints in configure_empty_storage"
    },
    {
        "Id": "scroll-tech/mpt-circuit/zellic_Missing_range_check_for_address_values_in_MPT_Circuit",
        "Path": "dataset/halo2/scroll-tech/mpt-circuit/zellic_Missing_range_check_for_address_values_in_MPT_Circuit",
        "Project": "https://github.com/scroll-tech/mpt-circuit",
        "Commit": "0x25dd32aa316ec842ffe79bb8efe9f05f86edc33e",
        "Fix Commit": "e4f5df31e9b3005bb5977c11aa0c3b262cfe3269",
        "DSL": "Halo2",
        "Vulnerability": "Under-Constrained",
        "Impact": "Soundness",
        "Root Cause": "Missing Input Constraints",
        "Reproduced": false,
        "Location": {
            "Path": "MPTCircuit/gadgets/mpt_update.rs",
            "Function": "",
            "Line": "47"
        },
        "Source": {
            "Audit Report": {
                "Source Link": "https://github.com/zksecurity/zkbugs/blob/main/reports/documents/zellic-scroll-2.pdf",
                "Bug ID": "Missing range check for address values in MPT Circuit"
            }
        },
        "Commands": {
            "Setup Environment": "",
            "Reproduce": "",
            "Compile and Preprocess": "",
            "Positive Test": "",
            "Find Exploit": "",
            "Clean": ""
        },
        "Short Description of the Vulnerability": "The bug \"Missing range check for address values in MPT Circuit\" relates to the lack of validation for account addresses used as MPT keys, which could lead to multiple keys being generated for the same address. This situation risks creating inconsistencies in the state trie, as the absence of range checks enables potential attackers to manipulate values. The recommendation is to implement appropriate checks to ensure address values fall within specific byte ranges.",
        "Short Description of the Exploit": "",
        "Proposed Mitigation": "Add appropriate range checks for the account address and associated values in the MPT Circuit, ensuring that the address is within 20 bytes (160 bits), the address_high within 16 bytes (128 bits), and the calculated address_low (before multiplication by 2^96) within 4 bytes (32 bits).",
        "title": "Missing range check for address values in MPT Circuit"
    },
    {
        "Id": "scroll-tech/mpt-circuit/trailofbits_The_OneHot_primitive_allows_more_than_one_value_at_once",
        "Path": "dataset/halo2/scroll-tech/mpt-circuit/trailofbits_The_OneHot_primitive_allows_more_than_one_value_at_once",
        "Project": "https://github.com/scroll-tech/mpt-circuit",
        "Commit": "0xfc6c8a2972870e62e96cde480b3aa48c0cc1303d",
        "Fix Commit": "34af759e94f4b342507778145e7ae364a6d5566e",
        "DSL": "Halo2",
        "Vulnerability": "Under-Constrained",
        "Impact": "Soundness",
        "Root Cause": "Missing Input Constraints",
        "Reproduced": false,
        "Location": {
            "Path": "constraint_builder/binary_column.rs",
            "Function": "",
            "Line": "29-37"
        },
        "Source": {
            "Audit Report": {
                "Source Link": "https://github.com/zksecurity/zkbugs/blob/main/reports/documents/trailofbits-scroll-2.pdf",
                "Bug ID": "The OneHot primitive allows more than one value at once"
            }
        },
        "Commands": {
            "Setup Environment": "",
            "Reproduce": "",
            "Compile and Preprocess": "",
            "Positive Test": "",
            "Find Exploit": "",
            "Clean": ""
        },
        "Short Description of the Vulnerability": "The bug regarding the \"OneHot\" primitive indicates that it permits multiple values to be set simultaneously, despite its intended functionality to enforce exclusivity among its options. This lack of constraint allows a malicious prover to potentially manipulate key values within the Merkle path-checking state machine, compromising its integrity. A fix has since been implemented to enforce constraints ensuring that only one value can be active at a time.",
        "Short Description of the Exploit": "",
        "Proposed Mitigation": "To fix the issue with the OneHot primitive allowing more than one value at once, enforce constraints that ensure each binary column value is Boolean, specifically by adding the condition 1 - v.or(!v) == 0.",
        "title": "The OneHot primitive allows more than one value at once"
    },
    {
        "Id": "summa-dev/summa-solvency/Constant_assignment_to_check_bug",
        "Path": "dataset/halo2/summa-dev/summa-solvency/Constant_assignment_to_check_bug",
        "Project": "https://github.com/summa-dev/summa-solvency",
        "Commit": "",
        "Fix Commit": "",
        "DSL": "Halo2",
        "Vulnerability": "Under-Constrained",
        "Impact": "Soundness",
        "Root Cause": "Assigned but Unconstrained",
        "Reproduced": false,
        "Location": {
            "Path": "",
            "Function": "",
            "Line": ""
        },
        "Source": {
            "Audit Report": {
                "Source Link": "https://github.com/summa-dev/summa-solvency/issues/32",
                "Bug ID": "Constant assignment to check bug"
            }
        },
        "Commands": {
            "Setup Environment": "",
            "Reproduce": "",
            "Compile and Preprocess": "",
            "Positive Test": "",
            "Find Exploit": "",
            "Clean": ""
        },
        "Short Description of the Vulnerability": "",
        "Short Description of the Exploit": "",
        "Proposed Mitigation": "",
        "title": "Constant assignment to check bug"
    },
    {
        "Id": "risc0/risc0/ghsa-g3qg-6746-3mg9",
        "Project": "https://github.com/risc0/risc0",
        "Commit": "98387806fe8348d87e32974468c6f35853356ad5",
        "Fix Commit": "67f2d81c638bff5f4fcfe11a084ebb34799b7a89",
        "zkVM": true,
        "DSL": "risc0",
        "Vulnerability": "Under-Constrained",
        "Impact": "Soundness",
        "Root Cause": "Missing Constraint",
        "Reproduced": false,
        "Location": {
            "Path": "risc0/circuit/rv32im/src/execute/rv32im.rs",
            "Function": "step_compute, step_store",
            "Line": "327, 504"
        },
        "Source": {
            "GitHub Security Advisory": {
                "Source Link": "https://github.com/risc0/risc0/security/advisories/GHSA-g3qg-6746-3mg9",
                "Bug ID": "GHSA-g3qg-6746-3mg9: zkVM Underconstrained Vulnerability"
            }
        },
        "Commands": {
            "Setup Environment": "./zkbugs_setup.sh",
            "Reproduce": "",
            "Compile and Preprocess": "",
            "Positive Test": "",
            "Find Exploit": "",
            "Clean": "./zkbugs_clean.sh"
        },
        "Short Description of the Vulnerability": "Due to a missing constraint in the rv32im circuit, any 3-register RISC-V instruction (including remu and divu) in risc0-zkvm 2.0.0-2.0.2 are vulnerable to an attack by a malicious prover. When rs1 == rs2, the vulnerable code performs two register reads to the same address in a single memory cycle, but the circuit's memory subsystem lacks proper constraints to handle multiple accesses to the same address within one cycle, creating an underconstrained state. Reported by Christoph Hochrainer via Hackenproof bug bounty. Fixed in PR #3181 (squash merge).",
        "Short Description of the Exploit": "Would require crafting malicious proofs that exploit the underconstrained double-read scenario when rs1 == rs2 in 3-register RISC-V instructions.",
        "Proposed Mitigation": "Fix implemented in zirgen/pull/238 (circuit fix) and risc0/pull/3181 (risc0 update). Upgrade to risc0-zkvm version 2.1.0 or later, or risc0-circuit-rv32im version 2.0.4 or later. On-chain verifiers were disabled via estop mechanism.",
        "title": "zkVM underconstrained vulnerability in 3-register instructions"
    },
    {
        "Id": "risc0/risc0/ghsa-5c79-r6x7-3jx9",
        "Project": "https://github.com/risc0/risc0",
        "Commit": "a165a6e3443fbc2e4f7093d7552399cd56337928",
        "Fix Commit": "1e6ca468f3fb94ef6939b4f7875848312a708528",
        "zkVM": true,
        "DSL": "risc0",
        "Vulnerability": "Under-Constrained",
        "Impact": "Soundness",
        "Root Cause": "Missing Constraint",
        "Reproduced": false,
        "Location": {
            "Path": "risc0/circuit/rv32im-sys/cxx/step_exec.cpp",
            "Function": "step_exec",
            "Line": "6053-6063 (example of cross-cycle validation; 16+ similar blocks throughout file missing in buggy version)"
        },
        "Source": {
            "GitHub Security Advisory": {
                "Source Link": "https://github.com/risc0/risc0/security/advisories/GHSA-5c79-r6x7-3jx9",
                "Bug ID": "GHSA-5c79-r6x7-3jx9: Insufficient zkVM validation of multi-step instruction modes"
            }
        },
        "Commands": {
            "Setup Environment": "./zkbugs_setup.sh",
            "Reproduce": "",
            "Compile and Preprocess": "",
            "Positive Test": "",
            "Find Exploit": "",
            "Clean": "./zkbugs_clean.sh"
        },
        "Short Description of the Vulnerability": "Certain RISC-V instructions require multiple zkVM cycles for execution. During the first cycle of a multi-cycle instruction, the zkVM sets a major_mode which tells the zkVM how to continue the instruction during the subsequent cycle. Prior to v1.1.0, the zkVM circuit lacked constraints to ensure that the major mode had definitively been set by the previous instruction, including missing nextMajor register, majorMux component, and extern functions (extern_isTrap, extern_setUserMode) for mode validation. This under-constrained circuit could potentially allow invalid proofs to verify.",
        "Short Description of the Exploit": "Potential attack would require manipulating the major mode during multi-cycle RISC-V instruction execution without proper constraints to generate invalid proofs that successfully verify.",
        "Proposed Mitigation": "Fixed in v1.1.0 (commit 1e6ca468f from Aug 2, 2024) by comprehensive circuit update adding: (1) nextMajor register to BodyStep, (2) majorMux and majorSelect components, (3) extern_isTrap and extern_setUserMode functions. Advisory published Sep 25, 2024 recommends >= v1.1.1. Official verifier contracts deprecated verification of <1.1.1 receipts as of October 31, 2024.",
        "title": "Insufficient zkVM validation of multi-step instruction modes"
    },
    {
        "Id": "risc0/risc0/ghsa-f6rc-24x4-ppxp",
        "Project": "https://github.com/risc0/risc0",
        "Commit": "c8fd3bd2e2e18ad7a5abce213a376432116db039",
        "Fix Commit": "bef7bf580eb13d5467074b5f6075a986734d3fe5",
        "zkVM": true,
        "DSL": "risc0",
        "Vulnerability": "Under-Constrained",
        "Impact": "Soundness",
        "Root Cause": "Missing Constraint",
        "Reproduced": false,
        "Location": {
            "Path": "risc0/circuit/rv32im-sys/kernels/cxx/steps.cpp",
            "Function": "exec_DoDiv",
            "Line": "1335-1355"
        },
        "Source": {
            "GitHub Security Advisory": {
                "Source Link": "https://github.com/risc0/risc0/security/advisories/GHSA-f6rc-24x4-ppxp",
                "Bug ID": "GHSA-f6rc-24x4-ppxp: Underconstrained Vulnerability Division"
            }
        },
        "Commands": {
            "Setup Environment": "./zkbugs_setup.sh",
            "Reproduce": "",
            "Compile and Preprocess": "",
            "Positive Test": "",
            "Find Exploit": "",
            "Clean": "./zkbugs_clean.sh"
        },
        "Short Description of the Vulnerability": "Two issues were found in the risc0-circuit-rv32im circuit: (1) For some inputs to signed integer division, the circuit allowed two outputs, only one of which was valid. (2) The result of division by zero was underconstrained. This vulnerability was identified using the Picus tool from Veridise. Affected versions: risc0-zkvm >= 2.0, < 2.2.",
        "Short Description of the Exploit": "Would require crafting inputs to signed division operations that produce invalid outputs, or exploiting underconstrained division by zero.",
        "Proposed Mitigation": "Fixed in PR #3235 and zirgen issue #249. Upgrade to risc0-zkvm version 2.2.0 or later, or risc0-circuit-rv32im version 3.0.0 or later. On-chain verifiers were disabled via estop mechanism.",
        "title": "Underconstrained vulnerability in division"
    },
    {
        "Id": "starkware-libs/stark-perpetual/abdk_This_function_cannot_handle_the_case_when_n_risk_factor_segments_is_zero.",
        "Path": "dataset/cairo/starkware-libs/stark-perpetual/abdk_This_function_cannot_handle_the_case_when_n_risk_factor_segments_is_zero",
        "Project": "https://github.com/starkware-libs/stark-perpetual",
        "Commit": "0xe6189aa",
        "Fix Commit": "3eb3a26366f412cf8d0643f65e33d8b2eb5904fc",
        "DSL": "Cairo",
        "Vulnerability": "Under-Constrained",
        "Impact": "Soundness",
        "Root Cause": "Missing Input Constraints",
        "Reproduced": false,
        "Location": {
            "Path": "execute_batch_utils.cairo",
            "Function": "validate_risk_factor_function",
            "Line": "78"
        },
        "Source": {
            "Audit Report": {
                "Source Link": "https://github.com/zksecurity/zkbugs/blob/main/reports/documents/abdk-perpetual.pdf",
                "Bug ID": "This function cannot handle the case when n_risk_factor_segments is zero."
            }
        },
        "Commands": {
            "Setup Environment": "",
            "Reproduce": "",
            "Compile and Preprocess": "",
            "Positive Test": "",
            "Find Exploit": "",
            "Clean": ""
        },
        "Short Description of the Vulnerability": "The bug occurs when the function 'execute_batch_utils.cairo' cannot process a scenario where the variable 'n_risk_factor_segments' is set to zero. This situation leads to unclear behavior that may affect the function's robustness or cause unexpected results. The recommendation is to consider explicitly forbidding this case through an assertion in the code to ensure stability and predictability.",
        "Short Description of the Exploit": "",
        "Proposed Mitigation": "The recommended fix is to explicitly forbid the case where n_risk_factor_segments is zero via an assert.",
        "title": "This function cannot handle the case when n_risk_factor_segments is zero."
    },
    {
        "Id": "HerodotusDev/offchain-evm-headers-processor/abdk_Function_doesn’t_ensure_that_“y”_is_a_power_of_two.",
        "Path": "dataset/cairo/HerodotusDev/offchain-evm-headers-processor/abdk_Function_doesnt_ensure_that_y_is_a_power_of_two",
        "Project": "https://github.com/HerodotusDev/offchain-evm-headers-processor",
        "Commit": "0xb14e74a5a67bd4882383993036658a57f871e12b",
        "Fix Commit": "af97dae8be5cca025f42da9334596de50762c855",
        "DSL": "Cairo",
        "Vulnerability": "Under-Constrained",
        "Impact": "Soundness",
        "Root Cause": "Missing Input Constraints",
        "Reproduced": false,
        "Location": {
            "Path": "",
            "Function": "",
            "Line": ""
        },
        "Source": {
            "Audit Report": {
                "Source Link": "https://github.com/zksecurity/zkbugs/blob/main/reports/documents/abdk-herodotus.pdf",
                "Bug ID": "Function doesn’t ensure that “y” is a power of two."
            }
        },
        "Commands": {
            "Setup Environment": "",
            "Reproduce": "",
            "Compile and Preprocess": "",
            "Positive Test": "",
            "Find Exploit": "",
            "Clean": ""
        },
        "Short Description of the Vulnerability": "",
        "Short Description of the Exploit": "",
        "Proposed Mitigation": "",
        "title": "Function doesn’t ensure that “y” is a power of two."
    },
    {
        "Id": "HerodotusDev/offchain-evm-headers-processor/abdk_Behaviour_is_undefined_if_position_is_not_range_checked.",
        "Path": "dataset/cairo/HerodotusDev/offchain-evm-headers-processor/abdk_Behaviour_is_undefined_if_position_is_not_range_checked",
        "Project": "https://github.com/HerodotusDev/offchain-evm-headers-processor",
        "Commit": "0xb14e74a5a67bd4882383993036658a57f871e12b",
        "Fix Commit": "af97dae8be5cca025f42da9334596de50762c855",
        "DSL": "Cairo",
        "Vulnerability": "Under-Constrained",
        "Impact": "Soundness",
        "Root Cause": "Missing Input Constraints",
        "Reproduced": false,
        "Location": {
            "Path": "",
            "Function": "",
            "Line": ""
        },
        "Source": {
            "Audit Report": {
                "Source Link": "https://github.com/zksecurity/zkbugs/blob/main/reports/documents/abdk-herodotus.pdf",
                "Bug ID": "Behaviour is undefined if position is not range checked."
            }
        },
        "Commands": {
            "Setup Environment": "",
            "Reproduce": "",
            "Compile and Preprocess": "",
            "Positive Test": "",
            "Find Exploit": "",
            "Clean": ""
        },
        "Short Description of the Vulnerability": "",
        "Short Description of the Exploit": "",
        "Proposed Mitigation": "",
        "title": "Behaviour is undefined if position is not range checked."
    },
    {
        "Id": "HerodotusDev/offchain-evm-headers-processor/abdk_Missing_range_checks_for_negative_values",
        "Path": "dataset/cairo/HerodotusDev/offchain-evm-headers-processor/abdk_Missing_range_checks_for_negative_values",
        "Project": "https://github.com/HerodotusDev/offchain-evm-headers-processor",
        "Commit": "0xb14e74a5a67bd4882383993036658a57f871e12b",
        "Fix Commit": "eb30c321f41880b35a7af069f7f52fd98d584616",
        "DSL": "Cairo",
        "Vulnerability": "Under-Constrained",
        "Impact": "Soundness",
        "Root Cause": "Arithmetic Field Issues",
        "Reproduced": false,
        "Location": {
            "Path": "",
            "Function": "",
            "Line": ""
        },
        "Source": {
            "Audit Report": {
                "Source Link": "https://github.com/zksecurity/zkbugs/blob/main/reports/documents/abdk-herodotus.pdf",
                "Bug ID": "Missing range checks for negative values"
            }
        },
        "Commands": {
            "Setup Environment": "",
            "Reproduce": "",
            "Compile and Preprocess": "",
            "Positive Test": "",
            "Find Exploit": "",
            "Clean": ""
        },
        "Short Description of the Vulnerability": "",
        "Short Description of the Exploit": "",
        "Proposed Mitigation": "",
        "title": "Missing range checks for negative values"
    },
    {
        "Id": "HerodotusDev/offchain-evm-headers-processor/abdk_Behaviour_is_undefined_if_mmr_offset_is_not_range_checked.",
        "Path": "dataset/cairo/HerodotusDev/offchain-evm-headers-processor/abdk_Behaviour_is_undefined_if_mmr_offset_is_not_range_checked",
        "Project": "https://github.com/HerodotusDev/offchain-evm-headers-processor",
        "Commit": "0xb14e74a5a67bd4882383993036658a57f871e12b",
        "Fix Commit": "af97dae8be5cca025f42da9334596de50762c855",
        "DSL": "Cairo",
        "Vulnerability": "Under-Constrained",
        "Impact": "Soundness",
        "Root Cause": "Missing Input Constraints",
        "Reproduced": false,
        "Location": {
            "Path": "",
            "Function": "",
            "Line": ""
        },
        "Source": {
            "Audit Report": {
                "Source Link": "https://github.com/zksecurity/zkbugs/blob/main/reports/documents/abdk-herodotus.pdf",
                "Bug ID": "Behaviour is undefined if mmr_offset is not range checked."
            }
        },
        "Commands": {
            "Setup Environment": "",
            "Reproduce": "",
            "Compile and Preprocess": "",
            "Positive Test": "",
            "Find Exploit": "",
            "Clean": ""
        },
        "Short Description of the Vulnerability": "",
        "Short Description of the Exploit": "",
        "Proposed Mitigation": "",
        "title": "Behaviour is undefined if mmr_offset is not range checked."
    },
    {
        "Id": "HerodotusDev/offchain-evm-headers-processor/abdk_Behaviour_is_undefined_if_mmr_len_is_not_range_checked.",
        "Path": "dataset/cairo/HerodotusDev/offchain-evm-headers-processor/abdk_Behaviour_is_undefined_if_mmr_len_is_not_range_checked",
        "Project": "https://github.com/HerodotusDev/offchain-evm-headers-processor",
        "Commit": "0xb14e74a5a67bd4882383993036658a57f871e12b",
        "Fix Commit": "af97dae8be5cca025f42da9334596de50762c855",
        "DSL": "Cairo",
        "Vulnerability": "Under-Constrained",
        "Impact": "Soundness",
        "Root Cause": "Missing Input Constraints",
        "Reproduced": false,
        "Location": {
            "Path": "",
            "Function": "",
            "Line": ""
        },
        "Source": {
            "Audit Report": {
                "Source Link": "https://github.com/zksecurity/zkbugs/blob/main/reports/documents/abdk-herodotus.pdf",
                "Bug ID": "Behaviour is undefined if mmr_len is not range checked."
            }
        },
        "Commands": {
            "Setup Environment": "",
            "Reproduce": "",
            "Compile and Preprocess": "",
            "Positive Test": "",
            "Find Exploit": "",
            "Clean": ""
        },
        "Short Description of the Vulnerability": "",
        "Short Description of the Exploit": "",
        "Proposed Mitigation": "",
        "title": "Behaviour is undefined if mmr_len is not range checked."
    },
    {
        "Id": "HerodotusDev/offchain-evm-headers-processor/abdk_Implicitly_requires_“value”_to_fit_into_128+32=160_bits.",
        "Path": "dataset/cairo/HerodotusDev/offchain-evm-headers-processor/abdk_Implicitly_requires_value_to_fit_into_128_32_160_bits",
        "Project": "https://github.com/HerodotusDev/offchain-evm-headers-processor",
        "Commit": "0xb14e74a5a67bd4882383993036658a57f871e12b",
        "Fix Commit": "af97dae8be5cca025f42da9334596de50762c855",
        "DSL": "Cairo",
        "Vulnerability": "Under-Constrained",
        "Impact": "Soundness",
        "Root Cause": "Missing Input Constraints",
        "Reproduced": false,
        "Location": {
            "Path": "",
            "Function": "",
            "Line": ""
        },
        "Source": {
            "Audit Report": {
                "Source Link": "https://github.com/zksecurity/zkbugs/blob/main/reports/documents/abdk-herodotus.pdf",
                "Bug ID": "Implicitly requires “value” to fit into 128+32=160 bits."
            }
        },
        "Commands": {
            "Setup Environment": "",
            "Reproduce": "",
            "Compile and Preprocess": "",
            "Positive Test": "",
            "Find Exploit": "",
            "Clean": ""
        },
        "Short Description of the Vulnerability": "",
        "Short Description of the Exploit": "",
        "Proposed Mitigation": "",
        "title": "Implicitly requires “value” to fit into 128+32=160 bits."
    },
    {
        "Id": "HerodotusDev/offchain-evm-headers-processor/abdk_Behaviour_is_undefined_if_peaks_len_is_not_range_checked.",
        "Path": "dataset/cairo/HerodotusDev/offchain-evm-headers-processor/abdk_Behaviour_is_undefined_if_peaks_len_is_not_range_checked",
        "Project": "https://github.com/HerodotusDev/offchain-evm-headers-processor",
        "Commit": "0xb14e74a5a67bd4882383993036658a57f871e12b",
        "Fix Commit": "af97dae8be5cca025f42da9334596de50762c855",
        "DSL": "Cairo",
        "Vulnerability": "Under-Constrained",
        "Impact": "Soundness",
        "Root Cause": "Missing Input Constraints",
        "Reproduced": false,
        "Location": {
            "Path": "",
            "Function": "",
            "Line": ""
        },
        "Source": {
            "Audit Report": {
                "Source Link": "https://github.com/zksecurity/zkbugs/blob/main/reports/documents/abdk-herodotus.pdf",
                "Bug ID": "Behaviour is undefined if peaks_len is not range checked."
            }
        },
        "Commands": {
            "Setup Environment": "",
            "Reproduce": "",
            "Compile and Preprocess": "",
            "Positive Test": "",
            "Find Exploit": "",
            "Clean": ""
        },
        "Short Description of the Vulnerability": "",
        "Short Description of the Exploit": "",
        "Proposed Mitigation": "",
        "title": "Behaviour is undefined if peaks_len is not range checked."
    },
    {
        "Id": "0xPolygonHermez/zkevm-proverjs/hexens_Missing_constraint_in_PIL_leading_to_execution_flow_hijack",
        "Path": "dataset/pil/0xPolygonHermez/zkevm-proverjs/hexens_Missing_constraint_in_PIL_leading_to_execution_flow_hijack",
        "Project": "https://github.com/0xPolygonHermez/zkevm-proverjs",
        "Commit": "0x313dc",
        "Fix Commit": "9d6a8948636c05d508694a90d192a0713562ce29",
        "DSL": "PIL",
        "Vulnerability": "Under-Constrained",
        "Impact": "Soundness",
        "Root Cause": "Missing Input Constraints",
        "Reproduced": false,
        "Location": {
            "Path": "utils.zkasm",
            "Function": "",
            "Line": ""
        },
        "Source": {
            "Audit Report": {
                "Source Link": "https://github.com/zksecurity/zkbugs/blob/main/reports/documents/hexens-polygonzkevm.pdf",
                "Bug ID": "Missing constraint in PIL leading to execution flow hijack"
            }
        },
        "Commands": {
            "Setup Environment": "",
            "Reproduce": "",
            "Compile and Preprocess": "",
            "Positive Test": "",
            "Find Exploit": "",
            "Clean": ""
        },
        "Short Description of the Vulnerability": "The bug titled \"Missing constraint in PIL leading to execution flow hijack\" involves a lacking constraint in the main.pil associated with the free input checking in zkEVM ROM. This absence allows the potential for execution flow hijack, enabling an attacker to specify arbitrary jump addresses in ROM, potentially increasing balance or causing other impacts. Furthermore, because of the missing constraint, the isNeg variable can improperly evaluate to values other than 0 or 1, thereby facilitating the unintended execution flow change. This bug was classified with a severity of Critical and has been fixed as per the report.",
        "Short Description of the Exploit": "",
        "Proposed Mitigation": "To fix the \"Missing constraint in PIL leading to execution flow hijack\" bug, add a constraint for the inNeg polynomial to ensure that it only evaluates to 0 or 1 using the equation: isNeg * (1-isNeg) = 0.",
        "title": "Missing constraint in PIL leading to execution flow hijack"
    },
    {
        "Id": "0xPolygonHermez/zkevm-proverjs/hexens_Missing_constraint_in_PIL_leading_to_proving_fake_inclusion_in_the_SMT",
        "Path": "dataset/pil/0xPolygonHermez/zkevm-proverjs/hexens_Missing_constraint_in_PIL_leading_to_proving_fake_inclusion_in_the_SMT",
        "Project": "https://github.com/0xPolygonHermez/zkevm-proverjs",
        "Commit": "0x313dc",
        "Fix Commit": "40d1846b50aa6b9e006a85fde99261a8c5c7b8f2",
        "DSL": "PIL",
        "Vulnerability": "Under-Constrained",
        "Impact": "Soundness",
        "Root Cause": "Missing Input Constraints",
        "Reproduced": false,
        "Location": {
            "Path": "storage.pil",
            "Function": "",
            "Line": ""
        },
        "Source": {
            "Audit Report": {
                "Source Link": "https://github.com/zksecurity/zkbugs/blob/main/reports/documents/hexens-polygonzkevm.pdf",
                "Bug ID": "Missing constraint in PIL leading to proving fake inclusion in the SMT"
            }
        },
        "Commands": {
            "Setup Environment": "",
            "Reproduce": "",
            "Compile and Preprocess": "",
            "Positive Test": "",
            "Find Exploit": "",
            "Clean": ""
        },
        "Short Description of the Vulnerability": "The bug involves a missing binary constraint in the polynomial identity layer (PIL) of a storage state machine using Sparse Merkle Tree (SMT), which is crucial for proving (Key, Value) pair inclusions. Due to the absent constraint, it's theoretically possible to manipulate the key path traversal in the SMT proof process, enabling the proof of a fake key-value binding. This can lead to incorrect validations and potentially fraudulent activities. The PIL implementation overlooked enforcing that the key representation in traversing operations strictly adheres to binary values (0 or 1), inadvertently permitting other values that could jeopardize the integrity of tree traversal and proof verification operations. The remedy was to add a required binary constraint to ensure key traversal operations and their validations remain secure and accurate.",
        "Short Description of the Exploit": "",
        "Proposed Mitigation": "The recommended fix for the bug 'Missing constraint in PIL leading to proving fake inclusion in the SMT' is to add the missing binary constraint.",
        "title": "Missing constraint in PIL leading to proving fake inclusion in the SMT"
    },
    {
        "Id": "penumbra-zone/penumbra/nccgroup_Invalid_Comparisons_on_Fixed-Point_Values_are_Accepted_by_the_Circuit_Verifier",
        "Path": "dataset/arkworks/penumbra-zone/penumbra/nccgroup_Invalid_Comparisons_on_Fixed_Point_Values_are_Accepted_by_the_Circuit_Verifier",
        "Project": "https://github.com/penumbra-zone/penumbra",
        "Commit": "0xa43b594",
        "Fix Commit": "954b3b2e678075baf1e06279ea41bb2823e540c76ddb80ba44b52476dfd3f55f",
        "DSL": "Arkworks",
        "Vulnerability": "Under-Constrained",
        "Impact": "Soundness",
        "Root Cause": "Wrong Translation of Logic into Constraints",
        "Reproduced": false,
        "Location": {
            "Path": "penumbra/crates/core/num/src/fixpoint.rs",
            "Function": "U128x128Var::enforce_cmp",
            "Line": "428-459"
        },
        "Source": {
            "Audit Report": {
                "Source Link": "https://github.com/zksecurity/zkbugs/blob/main/reports/documents/nccgroup-penumbra.pdf",
                "Bug ID": "Invalid Comparisons on Fixed-Point Values are Accepted by the Circuit Verifier"
            }
        },
        "Commands": {
            "Setup Environment": "",
            "Reproduce": "",
            "Compile and Preprocess": "",
            "Positive Test": "",
            "Find Exploit": "",
            "Clean": ""
        },
        "Short Description of the Vulnerability": "The bug causes an arithmetic circuit designed to compare fixed-point values to accept invalid input pairs, making such checks unreliable. Specifically, this flaw in the comparison logic within the circuit means that it may incorrectly validate comparisons as true even when one value is not genuinely greater than or less than the other, which de-secures any cryptographic mechanism relying on such comparisons for correctness assurance.",
        "Short Description of the Exploit": "",
        "Proposed Mitigation": "To fix the issue of invalid comparisons on fixed-point values which are accepted by the circuit verifier, modify the bit-wise comparison logic in the circuit to correctly stop at the first discrepancy between input values. Implement two Boolean variables (e.g., 'gt' for \"greater than\" and 'lt' for \"lower than\") to improve the ternary state handling during bit comparisons, ensuring that the comparisons detect true inequalities between bit sequences. Additionally, add unit tests that specifically check invalid inequalities to ensure the prover refuses to create a proof for them.",
        "title": "Invalid Comparisons on Fixed-Point Values are Accepted by the Circuit Verifier"
    },
    {
        "Id": "penumbra-zone/penumbra/zksecurity_Unsound_fixed-point_addition",
        "Path": "dataset/arkworks/penumbra-zone/penumbra/zksecurity_Unsound_fixed_point_addition",
        "Project": "https://github.com/penumbra-zone/penumbra",
        "Commit": "0xa43b594",
        "Fix Commit": "ddab070acff5567f23eb36a4a877358f2c062d9b",
        "DSL": "Arkworks",
        "Vulnerability": "Computational Issues",
        "Impact": "Soundness",
        "Root Cause": "Wrong Translation of Logic into Constraints",
        "Reproduced": false,
        "Location": {
            "Path": "core/num",
            "Function": "checked_add",
            "Line": ""
        },
        "Source": {
            "Audit Report": {
                "Source Link": "https://github.com/zksecurity/zkbugs/blob/main/reports/documents/zksecurity-penumbra.pdf",
                "Bug ID": "Unsound fixed-point addition"
            }
        },
        "Commands": {
            "Setup Environment": "",
            "Reproduce": "",
            "Compile and Preprocess": "",
            "Positive Test": "",
            "Find Exploit": "",
            "Clean": ""
        },
        "Short Description of the Vulnerability": "The bug 'Unsound fixed-point addition' involves a fault in the fixed-point arithmetic used in Penumbra's logic. The `checked_add` function in `U128x128Var`, a 256-bit type, underconstrains some operations, potentially leading to incorrect results. This function converts limbs to field values and adds them, tracking carry for each limb and ensuring no overflow. However, the carry bit, resulting from adding two 64-bit values that produce a 65-bit result, is not properly managed. This improper handling could erroneously set all carry bits (`c1`) to zero during proving, leading to unsound additions in certain scenarios.",
        "Short Description of the Exploit": "",
        "Proposed Mitigation": "To fix the issue of unsound fixed-point addition in Penumbra's circuits, Penumbra released a fix that correctly computes each limb in the circuit.",
        "title": "Unsound fixed-point addition"
    },
    {
        "Id": "penumbra-zone/penumbra/zksecurity_Unsound_fixed-point_multiplication",
        "Path": "dataset/arkworks/penumbra-zone/penumbra/zksecurity_Unsound_fixed_point_multiplication",
        "Project": "https://github.com/penumbra-zone/penumbra",
        "Commit": "0xa43b594",
        "Fix Commit": "1fdbe1ea10a270180c035aeb8bb7f4a3ff25d99e",
        "DSL": "Arkworks",
        "Vulnerability": "Computational Issues",
        "Impact": "Soundness",
        "Root Cause": "Wrong Translation of Logic into Constraints",
        "Reproduced": false,
        "Location": {
            "Path": "core/num",
            "Function": "U128x128Var::checked_mul",
            "Line": ""
        },
        "Source": {
            "Audit Report": {
                "Source Link": "https://github.com/zksecurity/zkbugs/blob/main/reports/documents/zksecurity-penumbra.pdf",
                "Bug ID": "Unsound fixed-point multiplication"
            }
        },
        "Commands": {
            "Setup Environment": "",
            "Reproduce": "",
            "Compile and Preprocess": "",
            "Positive Test": "",
            "Find Exploit": "",
            "Clean": ""
        },
        "Short Description of the Vulnerability": "The 'Unsound fixed-point multiplication' bug occurs when scaling two fixed-point values in the multiplication operation, leading to improper computation of the result due to incorrect limb handling. This error is critical as it impacts the accuracy of fixed-point arithmetic operations in the system, specifically in the context of financial calculations where precision is paramount. The issue lies in incorrectly accounting for overflow and implementing the truncation step required to maintain precision, essentially failing to scale back the multiplied result properly.",
        "Short Description of the Exploit": "",
        "Proposed Mitigation": "Penumbra fixed the issue of unsound fixed-point multiplication by correctly constraining the limbs in the circuit.",
        "title": "Unsound fixed-point multiplication"
    },
    {
        "Id": "penumbra-zone/penumbra/zksecurity_Double_spending_due_to_incoming_viewing_key_(ivk)_derivation_not_constrained",
        "Path": "dataset/arkworks/penumbra-zone/penumbra/zksecurity_Double_spending_due_to_incoming_viewing_key_ivk_derivation_not_constrained",
        "Project": "https://github.com/penumbra-zone/penumbra",
        "Commit": "0xa43b594",
        "Fix Commit": "e019839939968012ed2d24cf65bdd86d239b50e9",
        "DSL": "Arkworks",
        "Vulnerability": "Under-Constrained",
        "Impact": "Soundness",
        "Root Cause": "Out-of-Circuit Computation Not Being Constrained",
        "Reproduced": false,
        "Location": {
            "Path": "core/keys",
            "Function": "IncomingViewingKeyVar::derive",
            "Line": ""
        },
        "Source": {
            "Audit Report": {
                "Source Link": "https://github.com/zksecurity/zkbugs/blob/main/reports/documents/zksecurity-penumbra.pdf",
                "Bug ID": "Double spending due to incoming viewing key (ivk) derivation not constrained"
            }
        },
        "Commands": {
            "Setup Environment": "",
            "Reproduce": "",
            "Compile and Preprocess": "",
            "Positive Test": "",
            "Find Exploit": "",
            "Clean": ""
        },
        "Short Description of the Vulnerability": "The bug involving the derivation of the incoming viewing key (ivk) in Penumbra's protocols allows for potential double-spending issues due to insufficient constraints during the ivk derivation process. This security issue occurs because the ivk, which should be tightly linked to the nullifier key (nk) for correct operation, can be manipulated by a malicious user during the conversion process between circuit fields. This vulnerability could enable the spending of a note multiple times by varying the nullifier key, thus undermining the intended security guarantees of the system.",
        "Short Description of the Exploit": "",
        "Proposed Mitigation": "To resolve the issue of double spending due to unconstrained incoming viewing key (ivk) derivation, Penumbra addressed the problem by computing the reduced value `res` outside the circuit and proving that it correctly satisfies the equation `ivk_mod_q = quotient * r_modulus + res` modulo the circuit field `Fq`, with `quotient` being constrained to `<= 4`. This fix ensures that the modulus of the scalar field `Fr` is smaller than the circuit field `Fq`.",
        "title": "Double spending due to incoming viewing key (ivk) derivation not constrained"
    },
    {
        "Id": "arkworks-rs/r1cs-std/Enforce_mul_by_inverse",
        "Path": "dataset/arkworks-rs/r1cs-std/Enforce_mul_by_inverse",
        "Project": "https://github.com/arkworks-rs/r1cs-std",
        "Commit": "",
        "Fix Commit": "",
        "DSL": "Arkworks",
        "Vulnerability": "Under-Constrained",
        "Impact": "Soundness",
        "Root Cause": "Wrong Translation of Logic into Constraints",
        "Reproduced": false,
        "Location": {
            "Path": "",
            "Function": "",
            "Line": ""
        },
        "Source": {
            "Audit Report": {
                "Source Link": "https://github.com/arkworks-rs/r1cs-std/pull/70",
                "Bug ID": "Enforce mul_by_inverse"
            }
        },
        "Commands": {
            "Setup Environment": "",
            "Reproduce": "",
            "Compile and Preprocess": "",
            "Positive Test": "",
            "Find Exploit": "",
            "Clean": ""
        },
        "Short Description of the Vulnerability": "",
        "Short Description of the Exploit": "",
        "Proposed Mitigation": "",
        "title": "Enforce mul_by_inverse"
    },
    {
        "Id": "openvm-org/openvm/GHSA-4w7p-8f9q-f4g2",
        "Project": "https://github.com/openvm-org/openvm",
        "Commit": "7548bdf844db53c0a6fc9ed9f153c54422c6cfa4",
        "Fix Commit": "bdb4831fefed13b0741d3a052d434a9c995c6d5d",
        "zkVM": true,
        "DSL": "Plonky3",
        "Vulnerability": "Fiat-Shamir Issue",
        "Impact": "Soundness",
        "Root Cause": "Fiat-Shamir",
        "Reproduced": false,
        "Location": {
            "Path": "extensions/native/recursion/src/fri/mod.rs, extensions/native/recursion/src/fri/two_adic_pcs.rs",
            "Function": "verify_query, verify_two_adic_pcs",
            "Line": "63, 57"
        },
        "Source": {
            "GitHub Security Advisory": {
                "Source Link": "https://github.com/openvm-org/openvm/security/advisories/GHSA-4w7p-8f9q-f4g2",
                "Bug ID": "GHSA-4w7p-8f9q-f4g2: Plonky3 missing final polynomial degree check and randomness in FRI verifier"
            }
        },
        "Commands": {
            "Setup Environment": "./zkbugs_setup.sh",
            "Reproduce": "",
            "Compile and Preprocess": "",
            "Positive Test": "",
            "Find Exploit": "",
            "Clean": "./zkbugs_clean.sh"
        },
        "Short Description of the Vulnerability": "OpenVM is affected by vulnerabilities in the Plonky3 FRI verifier (Plonky3 CVE GHSA-f69f-5fx9-w9r9). Two issues exist: (1) When rolling in polynomials of lower degree, the FRI prover and verifier were adding low degree polynomials without any randomness (missing beta^2 term). A malicious prover could potentially abuse this to make high degree parts of polynomials cancel out. (2) The native FRI verifier was missing a final polynomial degree check, allowing the prover to pass in a higher than expected degree polynomial without detection. The OpenVM recursive verifier was not affected by the second vulnerability because it fixed final polynomial degree to 0 (constant), but did suffer from the first vulnerability in multi-FRI verification. Projects using OpenVM native verification SDK/CLI (verify_app_proof) are affected by both vulnerabilities. Projects using recursive verifier including EVM smart contract verifier are affected by the first vulnerability. Fixed in v1.2.0 via PR #1703.",
        "Short Description of the Exploit": "Would require crafting FRI proofs that exploit missing randomness to cancel out high degree polynomial terms, or pass polynomials with incorrect final degree that bypass verification checks.",
        "Proposed Mitigation": "Update recursive verifier to match Plonky3 fixes: (1) Introduce betas_squared array to precompute and cache beta^2 values for proper randomness when folding and rolling in reduced opening terms. (2) Enforce that proof.final_poly.len() equals config.final_poly_len(). Fixed in v1.2.0 by updating Plonky3 dependency and modifying OpenVM's recursive verifier implementation.",
        "title": "Plonky3 missing final polynomial degree check and randomness in FRI verifier"
    },
    {
        "Id": "openvm-org/openvm/GHSA-jf2r-x3j4-23m7",
        "Project": "https://github.com/openvm-org/openvm",
        "Commit": "f41640c37bc5468a0775a38098053fe37ea3538a",
        "Fix Commit": "68da4b50c033da5603517064aa0a08e1bbf70a01",
        "zkVM": true,
        "DSL": "Plonky3",
        "Vulnerability": "Under-Constrained",
        "Impact": "Soundness",
        "Root Cause": "Other Programming Errors",
        "Reproduced": false,
        "Location": {
            "Path": "extensions/rv32im/circuit/src/auipc/core.rs",
            "Function": "Rv32AuipcCoreAir::eval, Rv32AuipcCoreChip::execute_instruction",
            "Line": "133, 245"
        },
        "Source": {
            "GitHub Security Advisory": {
                "Source Link": "https://github.com/openvm-org/openvm/security/advisories/GHSA-jf2r-x3j4-23m7",
                "Bug ID": "CVE-2025-46723, GHSA-jf2r-x3j4-23m7: Byte decomposition of pc in AUIPC chip can overflow"
            }
        },
        "Commands": {
            "Setup Environment": "./zkbugs_setup.sh",
            "Reproduce": "",
            "Compile and Preprocess": "",
            "Positive Test": "",
            "Find Exploit": "",
            "Clean": "./zkbugs_clean.sh"
        },
        "Short Description of the Vulnerability": "The AUIPC (Add Upper Immediate to PC) chip in OpenVM's RISC-V circuit contains an off-by-one error in byte decomposition logic for the program counter. A typo in iterator method chaining (for (i, limb) in pc_limbs.iter().skip(1).enumerate()) causes enumeration to produce indices 0,1,2 when the code expects 1,2,3. This makes the condition 'if i == pc_limbs.len() - 1' never trigger for the highest limb pc_limbs[3], resulting in it being range-checked to 8 bits instead of the required 6 bits. The weakened constraint allows the decomposed representation of pc to overflow the BabyBear field, enabling a malicious prover to make the AUIPC instruction's destination register take an arbitrary incorrect value. This bug was ironically introduced as a typo while fixing a previous vulnerability (Cantina finding #21). Affected version: 1.0.0, patched in 1.1.0.",
        "Short Description of the Exploit": "An attacker exploits the insufficient range check on pc_limbs[3] by constructing a witness where the byte decomposition of the program counter intentionally overflows the BabyBear field. Since pc_limbs[3] accepts values up to 255 (8-bit) instead of the correct maximum of 63 (6-bit), the prover can craft limb values such that the reconstructed pc differs from the actual program counter value, breaking the integrity of the AUIPC instruction which computes rd = pc + (imm << 12) and allowing the destination register to be set to an attacker-controlled value.",
        "Proposed Mitigation": "Fix the iterator method order from .skip(1).enumerate() to .enumerate().skip(1). This ensures enumeration happens before skipping, producing indices 1,2,3 as expected by the logic. With correct indices, the conditional 'if i == pc_limbs.len() - 1' triggers when i equals 3 (the last limb index), properly applying the 6-bit range check to pc_limbs[3] to prevent field overflow.",
        "title": "AUIPC PC Byte Decomposition Overflow Due to Iterator Off-by-One Error"
    },
    {
        "Id": "succinctlabs/sp1/ghsa-f77q-r5qm-w4m8",
        "Project": "https://github.com/succinctlabs/sp1",
        "Commit": "798b695ec682fd922698df2b83857ecfc17c3195",
        "Fix Commit": "95d5df798738aaa6b348a3684602737d6ff74014",
        "zkVM": true,
        "DSL": "Plonky3",
        "Vulnerability": "Under-Constrained",
        "Impact": "Soundness",
        "Root Cause": "Arithmetic Field Issues",
        "Reproduced": false,
        "Location": {
            "Path": "crates/recursion/gnark-ffi/go/sp1/babybear/babybear.go",
            "Function": "invF, InvE",
            "Line": "136, 255"
        },
        "Source": {
            "GitHub Security Advisory": {
                "Source Link": "https://github.com/succinctlabs/sp1/security/advisories/GHSA-f77q-r5qm-w4m8",
                "Bug ID": "GHSA-f77q-r5qm-w4m8: Insufficient range checks of BabyBear arithmetic"
            }
        },
        "Commands": {
            "Setup Environment": "./zkbugs_setup.sh",
            "Reproduce": "",
            "Compile and Preprocess": "",
            "Positive Test": "",
            "Find Exploit": "",
            "Clean": "./zkbugs_clean.sh"
        },
        "Short Description of the Vulnerability": "The Gnark recursion circuit constrains arithmetic over BabyBear when the native field is BN254. Functions like invF and InvE used values generated by hints that were not appropriately range checked to ensure they were less than the BabyBear modulus, allowing potential soundness violations.",
        "Short Description of the Exploit": "A malicious prover can provide hint values for inverse calculations that are between 2013265921 (BabyBear modulus) and 2147483647 (2^31-1). These values pass the 31-bit range check but represent invalid BabyBear field elements, potentially allowing the prover to break soundness by using incorrect inverse values that still satisfy the multiplication constraint modulo BN254.",
        "Proposed Mitigation": "Add proper range checks in InvF and InvE functions to ensure all Bn254 values are constrained to be less than the BabyBear modulus.",
        "title": "Insufficient range checks of BabyBear arithmetic"
    },
    {
        "Id": "succinctlabs/sp1/ghsa-c873-wfhp-wx5m-1",
        "Project": "https://github.com/succinctlabs/sp1",
        "Commit": "1fa7d2050e6c0a5f6fc154a395f3e967022f7035",
        "Fix Commit": "7e2023b2cbd3c2c8e96399ef52784dd2ec08f617",
        "zkVM": true,
        "DSL": "Plonky3",
        "Vulnerability": "Backend Issue",
        "Impact": "Soundness",
        "Root Cause": "Missing/Incorrect Verifier Check",
        "Reproduced": false,
        "Location": {
            "Path": "crates/stark/src/verifier.rs",
            "Function": "verify_shard",
            "Line": "30"
        },
        "Source": {
            "GitHub Security Advisory": {
                "Source Link": "https://github.com/succinctlabs/sp1/security/advisories/GHSA-c873-wfhp-wx5m",
                "Bug ID": "GHSA-c873-wfhp-wx5m (Bug 1 of 3) Missing verifier checks and fiat-shamir observations"
            }
        },
        "Commands": {
            "Setup Environment": "./zkbugs_setup.sh",
            "Reproduce": "",
            "Compile and Preprocess": "",
            "Positive Test": "",
            "Find Exploit": "",
            "Clean": "./zkbugs_clean.sh"
        },
        "Short Description of the Vulnerability": "In SP1's STARK verifier, the prover-provided chip_ordering is used to fetch the index of chips that have preprocessed columns. Prior to v4.0.0, validation that this chip_ordering correctly provides these indexes was missing.",
        "Short Description of the Exploit": "Would require crafting a malicious proof with incorrect chip_ordering.",
        "Proposed Mitigation": "Add a check that the indexed chip's name is equal to the name stored in the verifying key's chip information (implemented in v4.0.0). Added after line 131 (in buggy commit) in verify_shard.",
        "title": "Missing chip_ordering validation in STARK verifier"
    },
    {
        "Id": "succinctlabs/sp1/ghsa-6248-228x-mmvh-2",
        "Project": "https://github.com/succinctlabs/sp1",
        "Commit": "ad212dd52bdf8f630ea47f2b58aa94d5b6e79904",
        "Fix Commit": "aa9a8e40b6527a06764ef0347d43ac9307d7bf63",
        "zkVM": true,
        "DSL": "Plonky3",
        "Vulnerability": "Computational Issues",
        "Impact": "Soundness",
        "Root Cause": "Other Programming Errors",
        "Reproduced": false,
        "Location": {
            "Path": "crates/zkvm/entrypoint/src/lib.rs",
            "Function": "read_vec_raw",
            "Line": "91"
        },
        "Source": {
            "GitHub Security Advisory": {
                "Source Link": "https://github.com/succinctlabs/sp1/security/advisories/GHSA-6248-228x-mmvh",
                "Bug ID": "GHSA-6248-228x-mmvh: (Bug 2 of 2) Insufficient checks in the Rust verifier and embedded allocators"
            }
        },
        "Commands": {
            "Setup Environment": "./zkbugs_setup.sh",
            "Reproduce": "",
            "Compile and Preprocess": "",
            "Positive Test": "",
            "Find Exploit": "",
            "Clean": "./zkbugs_clean.sh"
        },
        "Short Description of the Vulnerability": "SP1's embedded allocator had two overflow vulnerabilities: (1) In read_vec_raw function (introduced in v4.0.1), the check 'ptr + capacity > MAX_MEMORY' did not use overflow-safe arithmetic for the addition. When capacity is large (e.g., near u32::MAX), ptr + capacity can wrap around to a small address, bypassing the check. This allows arbitrary memory writes - for example, if a program does two read_vec calls, the second could corrupt the first buffer's memory. (2) The heap size calculation (_end to EMBEDDED_RESERVED_INPUT_START) had no check ensuring _end <= EMBEDDED_RESERVED_INPUT_START, potentially causing heap size overflow and overlap with the hint area. The bump allocator (default) was not affected by either issue. Found during Zellic audit, fixed in v5.0.0.",
        "Short Description of the Exploit": "Would require crafting malicious input with large capacity values to trigger overflow.",
        "Proposed Mitigation": "Replace unsafe addition with overflow-safe variant: change 'if ptr + capacity > MAX_MEMORY' to 'if ptr.saturating_add(capacity) > MAX_MEMORY'. saturating_add clamps to usize::MAX on overflow instead of wrapping, ensuring the check cannot be bypassed. Implemented in v5.0.0 (commit aa9a8e40).",
        "title": "Embedded allocator overflow vulnerabilities"
    },
    {
        "Id": "succinctlabs/sp1/ghsa-8m24-3cfx-9fjw",
        "Project": "https://github.com/succinctlabs/sp1",
        "Commit": "6512b56296c2c5e53b10cce1a741173a3d2dde68",
        "Fix Commit": "79884ffb1a2d10bfd2c272f864033577a052468a",
        "zkVM": true,
        "DSL": "Plonky3",
        "Vulnerability": "Fiat-Shamir Issue",
        "Impact": "Soundness",
        "Root Cause": "Fiat-Shamir",
        "Reproduced": false,
        "Location": {
            "Path": "crates/recursion/circuit/src/stark.rs",
            "Function": "verify_shard",
            "Line": "60"
        },
        "Source": {
            "GitHub Security Advisory": {
                "Source Link": "https://github.com/succinctlabs/sp1/security/advisories/GHSA-8m24-3cfx-9fjw",
                "Bug ID": "GHSA-8m24-3cfx-9fjw: Insufficient observation of cumulative sum"
            }
        },
        "Commands": {
            "Setup Environment": "./zkbugs_setup.sh",
            "Reproduce": "",
            "Compile and Preprocess": "",
            "Positive Test": "",
            "Find Exploit": "",
            "Clean": "./zkbugs_clean.sh"
        },
        "Short Description of the Vulnerability": "In the recursive verifier circuit's verify_shard function, the zeta challenge is sampled without first observing the cumulative sum values from the permutation argument into the Fiat-Shamir transcript. The vulnerability affects SP1 prior to v3.0.0, discovered during audit and fixed on October 15, 2024 in PR #1638.",
        "Short Description of the Exploit": "An attacker could exploit this by crafting a malicious proof where the cumulative sum values are manipulated to break permutation argument soundness. Since zeta and alpha are sampled before cumulative sums are committed to the transcript, these challenge values are independent of the cumulative sums. A malicious prover could potentially choose cumulative sum values that satisfy zeta-dependent constraints while violating the permutation argument's integrity. The attack would require finding witness values that make false constraints appear satisfied when evaluated at the manipulable zeta point.",
        "Proposed Mitigation": "Fixed in PR #1638 (Oct 15, 2024). The fix modifies verify_shard to observe both global_cumulative_sum and local_cumulative_sum for each chip's opened values into the challenger before sampling alpha and zeta challenges. Upgrade to SP1 v3.0.0 or later.",
        "title": "Insufficient observation of cumulative sum"
    },
    {
        "Id": "succinctlabs/sp1/ghsa-c873-wfhp-wx5m-2",
        "Project": "https://github.com/succinctlabs/sp1",
        "Commit": "4681d4f0298b387f074fc93f8254584db9d258de",
        "Fix Commit": "4fe8144f1d57b27503f23795320a4e0eedf464c5",
        "zkVM": true,
        "DSL": "Plonky3",
        "Vulnerability": "Under-Constrained",
        "Impact": "Soundness",
        "Root Cause": "Missing Input Constraints",
        "Reproduced": false,
        "Location": {
            "Path": "crates/recursion/circuit/src/machine/core.rs",
            "Function": "verify",
            "Line": "120"
        },
        "Source": {
            "GitHub Security Advisory": {
                "Source Link": "https://github.com/succinctlabs/sp1/security/advisories/GHSA-c873-wfhp-wx5m",
                "Bug ID": "GHSA-c873-wfhp-wx5m (Bug 2 of 3) Missing verifier checks and fiat-shamir observations"
            }
        },
        "Commands": {
            "Setup Environment": "./zkbugs_setup.sh",
            "Reproduce": "",
            "Compile and Preprocess": "",
            "Positive Test": "",
            "Find Exploit": "",
            "Clean": "./zkbugs_clean.sh"
        },
        "Short Description of the Vulnerability": "In SP1's recursive verifier, the is_complete boolean flag is used to flag a proof of complete execution. Prior to v4.0.0, this flag was underconstrained in parts of the recursive verifier, such as the first layer of recursion. This allows proofs of partial execution to be verified as proofs of complete execution.",
        "Short Description of the Exploit": "Would require crafting a proof of partial execution that gets verified as complete execution.",
        "Proposed Mitigation": "Add appropriate calls to the assert_complete function to constrain the correctness of the is_complete flag in all parts of the recursive verifier (implemented in v4.0.0).",
        "title": "Underconstrained is_complete flag in recursive verifier"
    },
    {
        "Id": "succinctlabs/sp1/ghsa-6248-228x-mmvh-1",
        "Project": "https://github.com/succinctlabs/sp1",
        "Commit": "ad212dd52bdf8f630ea47f2b58aa94d5b6e79904",
        "Fix Commit": "aa9a8e40b6527a06764ef0347d43ac9307d7bf63",
        "zkVM": true,
        "DSL": "Plonky3",
        "Vulnerability": "Under-Constrained",
        "Impact": "Soundness",
        "Root Cause": "Missing Input Constraints",
        "Reproduced": false,
        "Location": {
            "Path": "crates/prover/src/verify.rs",
            "Function": "verify_compressed, verify_shrink, verify_deferred_proof",
            "Line": "297, 335, 506"
        },
        "Source": {
            "GitHub Security Advisory": {
                "Source Link": "https://github.com/succinctlabs/sp1/security/advisories/GHSA-6248-228x-mmvh",
                "Bug ID": "GHSA-6248-228x-mmvh: (Bug 1 of 2) Insufficient checks in the Rust verifier and embedded allocators"
            }
        },
        "Commands": {
            "Setup Environment": "./zkbugs_setup.sh",
            "Reproduce": "",
            "Compile and Preprocess": "",
            "Positive Test": "",
            "Find Exploit": "",
            "Clean": "./zkbugs_clean.sh"
        },
        "Short Description of the Vulnerability": "In SP1's native Rust verifier (crates/prover/src/verify.rs), the verify_compressed, verify_shrink, and verify_deferred_proof functions validated verification keys by checking if their hash was in the precomputed recursion_vk_map, but did not validate that the vk_root field (merkle root of all valid verifying key hashes) in the proof's public values matched the expected precomputed vk_root. This allowed a malicious prover to submit proofs with an arbitrary/invalid vk_root that would still pass verification. The recursive verifier circuit and on-chain verifier were not affected as they correctly checked this issue. Found during Zellic audit, fixed in v5.0.0 (commit aa9a8e40).",
        "Short Description of the Exploit": "Would require crafting a malicious proof with an invalid vk_root that passes verification in compress/shrink/deferred stages.",
        "Proposed Mitigation": "Add explicit vk_root validation in the Rust verifier: check if public_values.vk_root != self.recursion_vk_root in verify_compressed, verify_shrink, and verify_deferred_proof functions. Return InvalidPublicValues error if mismatch detected. Implemented in v5.0.0 (commit aa9a8e40 at lines 323, 366, 549).",
        "title": "Missing vk_root validation in Rust verifier"
    },
    {
        "Id": "zkopru-network/zkopru/leastauthority-previously-correct-ownership-proof-disabled-via-code-changes",
        "Path": "dataset/circom/zkopru-network/zkopru/leastauthority_previously_correct_ownership_proof_disabled_via_code_changes",
        "Project": "https://github.com/zkopru-network/zkopru/releases/tag/audit-v1",
        "Commit": "1f5c880d47b6913f848861667b8de6b88dcfe10d",
        "Fix Commit": "6458fe4ef384d2f2198aae00e719a7f94c30f090",
        "DSL": "Circom",
        "Vulnerability": "Under-Constrained",
        "Impact": "Soundness",
        "Root Cause": "Unsafe Reuse of Circuit",
        "Reproduced": true,
        "Location": {
            "Path": "circuits/ownership_proof.circom",
            "Function": "OwnershipProof",
            "Line": "14"
        },
        "Source": {
            "Audit Report": {
                "Source Link": "https://github.com/zksecurity/zkbugs/blob/main/reports/documents/leastauthority-zkorpu.pdf",
                "Bug ID": "Issue C: Previously Correct Ownership Proof Disabled via Code Changes"
            }
        },
        "Commands": {
            "Setup Environment": "./zkbugs_setup.sh",
            "Reproduce": "./zkbugs_exploit.sh",
            "Compile and Preprocess": "./zkbugs_compile_setup.sh",
            "Positive Test": "./zkbugs_positive_test.sh",
            "Find Exploit": "./zkbugs_find_exploit.sh",
            "Clean": "./zkbugs_clean.sh"
        },
        "Short Description of the Vulnerability": "The circuit integrates with `EdDSAPoseidonVerifier` template from circomlib, but the `enabled` signal is set to 0, disabling the verification. There is no signature verification in the circuit, so attacker can craft some non-existent signature and still generate a valid proof.",
        "Short Description of the Exploit": "Run zkbugs_js_setup.sh to set up the circomlibjs environment. Do `node generateInput.js` to generate the input for the circuit. Here every field besides `S` is valid, the signature is hardcoded to `13371337` for demonstrating the bug.",
        "Proposed Mitigation": "Change the line of code to `eddsa.enabled <== 1`.",
        "title": "Previously Correct Ownership Proof Disabled via Code Changes"
    },
    {
        "Id": "zkopru-network/zkopru/leastauthority_Circuit_Does_Not_Check_the_ERC-20_Sum_Correctly_",
        "Path": "dataset/circom/zkopru-network/zkopru/leastauthority_Circuit_Does_Not_Check_the_ERC_20_Sum_Correctly_",
        "Project": "https://github.com/zkopru-network/zkopru",
        "Commit": "0x4236fc8a5cbf73b7f3860d87a1a447eea8d7abd4",
        "Fix Commit": "30a19913ce1a018ce26a34d3d6621fcd38579171",
        "DSL": "Circom",
        "Vulnerability": "Under-Constrained",
        "Impact": "Soundness",
        "Root Cause": "Circuit Design Issue",
        "Reproduced": false,
        "Location": {
            "Path": "circuits/lib/zk_transaction.circom",
            "Function": "",
            "Line": "255"
        },
        "Source": {
            "Audit Report": {
                "Source Link": "https://github.com/zksecurity/zkbugs/blob/main/reports/documents/leastauthority-zkorpu.pdf",
                "Bug ID": "Circuit Does Not Check the ERC-20 Sum Correctly "
            }
        },
        "Commands": {
            "Setup Environment": "",
            "Reproduce": "",
            "Compile and Preprocess": "",
            "Positive Test": "",
            "Find Exploit": "",
            "Clean": ""
        },
        "Short Description of the Vulnerability": "The Zkopru zk-SNARK circuit has an issue where it incorrectly checks the ERC-20 token sum during transactions. This oversight allows a scenario where the circuit only verifies the sum of tokens for addresses included in the input notes, but fails to check for other addresses. Consequently, this bug could potentially let a malicious actor drain funds by exploiting this loophole, undetectably taking tokens not accounted for in the input notes.",
        "Short Description of the Exploit": "",
        "Proposed Mitigation": "Modify the circuit to enforce that outputs do not contain ERC-20 addresses that are not part of any spend note. This issue was resolved by the Zkopru team during the audit.",
        "title": "Circuit Does Not Check the ERC-20 Sum Correctly "
    },
    {
        "Id": "privacy-scaling-explorations/maci/ProcessMessages_circuit_to_prevent_message_censorship_by_the_coordinator",
        "Path": "dataset/circom/privacy-scaling-explorations/maci/ProcessMessages_circuit_to_prevent_message_censorship_by_the_coordinator",
        "Project": "https://github.com/privacy-scaling-explorations/maci",
        "Commit": "",
        "Fix Commit": "",
        "DSL": "Circom",
        "Vulnerability": "Under-Constrained",
        "Impact": "Completeness",
        "Root Cause": "Circuit Design Issue",
        "Reproduced": false,
        "Location": {
            "Path": "",
            "Function": "",
            "Line": ""
        },
        "Source": {
            "Audit Report": {
                "Source Link": "https://github.com/privacy-scaling-explorations/maci/issues/320",
                "Bug ID": "ProcessMessages circuit to prevent message censorship by the coordinator"
            }
        },
        "Commands": {
            "Setup Environment": "",
            "Reproduce": "",
            "Compile and Preprocess": "",
            "Positive Test": "",
            "Find Exploit": "",
            "Clean": ""
        },
        "Short Description of the Vulnerability": "",
        "Short Description of the Exploit": "",
        "Proposed Mitigation": "",
        "title": "ProcessMessages circuit to prevent message censorship by the coordinator"
    },
    {
        "Id": "privacy-scaling-explorations/maci/hashcloak_Data_are_not_fully_verified_during_state_update",
        "Path": "dataset/circom/privacy-scaling-explorations/maci/hashcloak_Data_are_not_fully_verified_during_state_update",
        "Project": "https://github.com/privacy-scaling-explorations/maci",
        "Commit": "0x2db5f6",
        "Fix Commit": "6df6a4054da926b07f35c5befab4f1f8af33dcc6",
        "DSL": "Circom",
        "Vulnerability": "Under-Constrained",
        "Impact": "Soundness",
        "Root Cause": "Misimplementation of a Specification",
        "Reproduced": false,
        "Location": {
            "Path": "",
            "Function": "",
            "Line": ""
        },
        "Source": {
            "Audit Report": {
                "Source Link": "https://github.com/zksecurity/zkbugs/blob/main/reports/documents/hashcloak-maci.pdf",
                "Bug ID": "Data are not fully verified during state update"
            }
        },
        "Commands": {
            "Setup Environment": "",
            "Reproduce": "",
            "Compile and Preprocess": "",
            "Positive Test": "",
            "Find Exploit": "",
            "Clean": ""
        },
        "Short Description of the Vulnerability": "The bug 'Data are not fully verified during state update' is not explicitly listed in the report. However, the closest relevant issue described involves the initial conditions in the tallyVotes.circom file. The system does not correctly verify the initial tally commitment when processing the first batch of results, allowing a malicious coordinator to start with an arbitrary tally, potentially compromising the tally results. Suggestions include adding constraints to the tally in the first batch or initializing the tally commitment with a valid value in Poll.sol, but issues remain due to the limit on contract bytecode size.",
        "Short Description of the Exploit": "",
        "Proposed Mitigation": "To address the issue of data not being fully verified during state updates, add constraints to the current tally in case of the first batch in the tallyVotes circuit and consider not skipping verification and initializing the tally commitment in Poll.sol with a valid and expected commitment.",
        "title": "Data are not fully verified during state update"
    },
    {
        "Id": "tangle-network/protocol-solidity/veridise_incorrect_initialization_in_membership_circuits",
        "Project": "https://github.com/tangle-network/protocol-solidity",
        "Commit": "848d073bb17f0aaffc6d39f594cc59efedeaec89",
        "Fix Commit": "eeb4fc7a4883d513e3fe3adbe2c447133ccd39f2",
        "DSL": "Circom",
        "Vulnerability": "Computational Issues",
        "Impact": "Soundness",
        "Root Cause": "Wrong Translation of Logic into Constraints",
        "Reproduced": true,
        "Location": {
            "Path": "circuits/set/membership.circom",
            "Function": "SetMembership",
            "Line": "20"
        },
        "Source": {
            "Audit Report": {
                "Source Link": "https://github.com/zksecurity/zkbugs/blob/main/reports/documents/veridise-tangle-network-protocol-solidity.pdf",
                "Bug ID": "V-WBT-VUL-006"
            }
        },
        "Commands": {
            "Setup Environment": "./zkbugs_setup.sh",
            "Reproduce": "./zkbugs_exploit.sh",
            "Compile and Preprocess": "./zkbugs_compile_setup.sh",
            "Positive Test": "./zkbugs_positive_test.sh",
            "Find Exploit": "./zkbugs_find_exploit.sh",
            "Clean": "./zkbugs_clean.sh"
        },
        "Short Description of the Vulnerability": "The templates `SetMembership` try to check if an element e is in a set S by generating a constraint of the form: for all  s in S, product of (s - e) = 0. They do does this by iterating over elements s of the set S and building the product. The issue is that `product[0]` is initialized to `element` which makes the constarint to be trivailly satisfied when `element` is 0.",
        "Short Description of the Exploit": "The template `SetMembership` is used to check whether a computed Merkle root belongs to a set of known Merkle roots. A malicious user that knows how to compute a Merkle root equal to 0 could pass along the hashes and generate an invalid proof.",
        "Proposed Mitigation": "We recommend that `product[0]` is initialized to 1.",
        "title": "Incorrect Initialization in Membership Circuits"
    },
    {
        "Id": "semaphore-protocol/semaphore/veridise-V-SEM-VUL-001",
        "Path": "dataset/circom/semaphore-protocol/semaphore/veridise_no_zero_value_validation",
        "Project": "https://github.com/semaphore-protocol/semaphore",
        "Commit": "27320f17233b18de477a74919084fba76513470f",
        "Fix Commit": "",
        "DSL": "Circom",
        "Vulnerability": "Under-Constrained",
        "Impact": "Soundness",
        "Root Cause": "Missing Input Constraints",
        "Reproduced": true,
        "Location": {
            "Path": "circuits/semaphore.circom",
            "Function": "Semaphore",
            "Line": "47-88"
        },
        "Source": {
            "Audit Report": {
                "Source Link": "https://github.com/zksecurity/zkbugs/blob/main/reports/documents/veridise-semaphore.pdf",
                "Bug ID": "V-SEM-VUL-001: No Zero Value Validation"
            }
        },
        "Commands": {
            "Setup Environment": "./zkbugs_setup.sh",
            "Reproduce": "./zkbugs_exploit.sh",
            "Compile and Preprocess": "./zkbugs_compile_setup.sh",
            "Positive Test": "./zkbugs_positive_test.sh",
            "Find Exploit": "./zkbugs_find_exploit.sh",
            "Clean": "./zkbugs_clean.sh"
        },
        "Short Description of the Vulnerability": "The bug in the Semaphore protocol involves the use of a zeroValue in incremental Merkle trees, which acts as an implicit group member. This zeroValue cannot be removed, and its addition does not trigger a MemberAdded event, making it invisible in membership records. This allows the group creator guaranteed access, which can be problematic if the admin changes. Additionally, if common values like 0 are compromised, they could be used to gain unauthorized access to groups.",
        "Short Description of the Exploit": "generateInput.js gives all necessary inputs for the incremental merkle tree. In real-world attack, identityNullifier and identityTrapdoor should be correct values corresponding to `zeroValue` membership in the incremental merkle tree. Here we just use 0 to represent them. The actual checks are in the solidity contracts.",
        "Proposed Mitigation": "Disallow proofs where the leaf corresponds to the zeroValue to ensure only legitimate users are added.",
        "title": "No Zero Value Validation"
    },
    {
        "Id": "personaelabs/spartan-ecdsa/yacademy_Knowledge_of_any_member_signature_allow_to_generate_proof_of_membership",
        "Path": "dataset/circom/personaelabs/spartan-ecdsa/yacademy_Knowledge_of_any_member_signature_allow_to_generate_proof_of_membership",
        "Project": "https://github.com/personaelabs/spartan-ecdsa",
        "Commit": "0x3386b30d9b",
        "Fix Commit": "",
        "DSL": "Circom",
        "Vulnerability": "Under-Constrained",
        "Impact": "Soundness",
        "Root Cause": "Circuit Design Issue",
        "Reproduced": false,
        "Location": {
            "Path": "",
            "Function": "",
            "Line": ""
        },
        "Source": {
            "Audit Report": {
                "Source Link": "https://github.com/zksecurity/zkbugs/blob/main/reports/documents/yacademy-spartan.md",
                "Bug ID": "Knowledge of any member signature allow to generate proof of membership"
            }
        },
        "Commands": {
            "Setup Environment": "",
            "Reproduce": "",
            "Compile and Preprocess": "",
            "Positive Test": "",
            "Find Exploit": "",
            "Clean": ""
        },
        "Short Description of the Vulnerability": "",
        "Short Description of the Exploit": "",
        "Proposed Mitigation": "",
        "title": "Knowledge of any member signature allow to generate proof of membership"
    },
    {
        "Id": "personaelabs/spartan-ecdsa/yacademy-high-01",
        "Path": "dataset/circom/personaelabs/spartan-ecdsa/yacademy_input_signal_s_is_not_constrained_in_eff_ecdsa_circom",
        "Project": "https://github.com/personaelabs/spartan-ecdsa",
        "Commit": "3386b30d9b5b62d8a60735cbeab42bfe42e80429",
        "Fix Commit": "",
        "DSL": "Circom",
        "Vulnerability": "Under-Constrained",
        "Impact": "Soundness",
        "Root Cause": "Missing Input Constraints",
        "Reproduced": true,
        "Location": {
            "Path": "circuits/eff_ecdsa.circom",
            "Function": "EfficientECDSA",
            "Line": "25-28"
        },
        "Source": {
            "Audit Report": {
                "Source Link": "https://github.com/zksecurity/zkbugs/blob/main/reports/documents/yacademy-spartan.md",
                "Bug ID": "Input signal s is not constrained in eff_ecdsa.circom"
            }
        },
        "Commands": {
            "Setup Environment": "./zkbugs_setup.sh",
            "Reproduce": "./zkbugs_exploit.sh",
            "Compile and Preprocess": "./zkbugs_compile_setup.sh",
            "Positive Test": "./zkbugs_positive_test.sh",
            "Find Exploit": "./zkbugs_find_exploit.sh",
            "Clean": "./zkbugs_clean.sh"
        },
        "Short Description of the Vulnerability": "The circuit computes `pubKey = s * T + U` but `s` isn't constrained. If we set `s = 0` and `(Ux, Uy) = pubKey`, then `(Tx, Ty)` can be any pair of values.",
        "Short Description of the Exploit": "Set `s = 0` and rest of the inputs can be any number.",
        "Proposed Mitigation": "Add constraint to `s` so that `s * T` can't be skipped in the computation.",
        "Similar Bugs": [
            "iden3/circomlib/kobi_gurkan_mimc_hash_assigned_but_not_constrained",
            "reclaimprotocol/circom-chacha20/zksecurity_unsound_left_rotation"
        ],
        "title": "Input signal s is not constrained in eff_ecdsa.circom"
    },
    {
        "Id": "personaelabs/spartan-ecdsa/yacademy-high-03",
        "Path": "dataset/circom/personaelabs/spartan-ecdsa/yacademy_under_constrained_circuits_compromising_the_soundness_of_the_system",
        "Project": "https://github.com/personaelabs/spartan-ecdsa",
        "Commit": "3386b30d9b5b62d8a60735cbeab42bfe42e80429",
        "Fix Commit": "",
        "DSL": "Circom",
        "Vulnerability": "Under-Constrained",
        "Impact": "Soundness",
        "Root Cause": "Assigned but Unconstrained",
        "Reproduced": true,
        "Location": {
            "Path": "circuits/mul.circom",
            "Function": "K",
            "Line": "123-124"
        },
        "Source": {
            "Audit Report": {
                "Source Link": "https://github.com/zksecurity/zkbugs/blob/main/reports/documents/yacademy-spartan.md",
                "Bug ID": "Under constrained circuits compromising the soundness of the system"
            }
        },
        "Commands": {
            "Setup Environment": "./zkbugs_setup.sh",
            "Reproduce": "./zkbugs_exploit.sh",
            "Compile and Preprocess": "./zkbugs_compile_setup.sh",
            "Positive Test": "./zkbugs_positive_test.sh",
            "Find Exploit": "./zkbugs_find_exploit.sh",
            "Clean": "./zkbugs_clean.sh"
        },
        "Short Description of the Vulnerability": "The signals `slo` and `shi` are assigned but not constrained",
        "Short Description of the Exploit": "Modify `slo` or `shi`, then deduce all related intermediate signals and modify the witness.",
        "Proposed Mitigation": "Use `<==` instead of `<--`.",
        "title": "Under constrained circuits compromising the soundness of the system"
    },
    {
        "Id": "0xbok/circom-bigint/veridise-V-BIGINT-COD-001",
        "Path": "dataset/circom/0xbok/circom-bigint/veridise_missing_range_checks_in_bigmod",
        "Project": "https://github.com/0xbok/circom-bigint",
        "Commit": "436665bf01728ae8c581fdb39e8428cb6b835c37",
        "Fix Commit": "d3edd7503f48f98a71b6013c248ef3ad55e19703",
        "DSL": "Circom",
        "Vulnerability": "Under-Constrained",
        "Impact": "Soundness",
        "Root Cause": "Arithmetic Field Issues",
        "Reproduced": true,
        "Location": {
            "Path": "circuits/bigint.circom",
            "Function": "BigMod",
            "Line": "363-417"
        },
        "Source": {
            "Audit Report": {
                "Source Link": "https://github.com/zksecurity/zkbugs/blob/main/reports/documents/veridise-circomlib.pdf",
                "Bug ID": "V-BIGINT-COD-001: Missing range checks in BigMod"
            }
        },
        "Commands": {
            "Setup Environment": "./zkbugs_setup.sh",
            "Reproduce": "./zkbugs_exploit.sh",
            "Compile and Preprocess": "./zkbugs_compile_setup.sh",
            "Positive Test": "./zkbugs_positive_test.sh",
            "Find Exploit": "./zkbugs_find_exploit.sh",
            "Clean": "./zkbugs_clean.sh"
        },
        "Short Description of the Vulnerability": "The bug in the BigMod template arises from missing range checks on the remainder `mod[i]`, allowing it to exceed the expected range of `2**n`. This underconstrained error can be exploited by providing inputs that result in a remainder larger than `2^n`, potentially compromising the integrity of the circuit. Proper range checks are applied to the quotient `div[i]`, but not to `mod[i]`, leaving the system vulnerable to malicious inputs that break the invariant of the modulus operation.",
        "Short Description of the Exploit": "We design a pair of `a` and `b` such that the remainder after `divmod` overflows `2**126`.",
        "Proposed Mitigation": "Add additional range checking constraints for `mod[i]`. This can be done using the Num2Bits template.",
        "title": "Missing range checks in BigMod"
    },
    {
        "Id": "Unirep/Unirep/veridise-V-UNI-VUL-002",
        "Path": "dataset/circom/Unirep/Unirep/veridise_missing_range_checks_on_comparison_circuits",
        "Project": "https://github.com/Unirep/Unirep",
        "Commit": "0985a28c38c8b2e7b7a9e80f43e63179fdd08b89",
        "Fix Commit": "f7b0bcd39383d5ec4d17edec2ad91bc01333bf36",
        "DSL": "Circom",
        "Vulnerability": "Under-Constrained",
        "Impact": "Soundness",
        "Root Cause": "Unsafe Reuse of Circuit",
        "Reproduced": true,
        "Location": {
            "Path": "circuits/epochKeyLite.circom",
            "Function": "EpochKeyLite",
            "Line": "45-48"
        },
        "Source": {
            "Audit Report": {
                "Source Link": "https://github.com/zksecurity/zkbugs/blob/main/reports/documents/veridise-unirep.pdf",
                "Bug ID": "V-UNI-VUL-002: Missing Range Checks on Comparison Circuits"
            }
        },
        "Commands": {
            "Setup Environment": "./zkbugs_setup.sh",
            "Reproduce": "./zkbugs_exploit.sh",
            "Compile and Preprocess": "./zkbugs_compile_setup.sh",
            "Positive Test": "./zkbugs_positive_test.sh",
            "Find Exploit": "./zkbugs_find_exploit.sh",
            "Clean": "./zkbugs_clean.sh"
        },
        "Short Description of the Vulnerability": "Input of `LessThan(8)` is assumed to have <=8 bits, but there is no constraint for it in `LessThan` template. Attacker can use large values such as `p - 1` to trigger overflow and make something like `p - 1 < EPOCH_KEY_NONCE_PER_EPOCH` return true.",
        "Short Description of the Exploit": "Set `nonce = -1` in `input.json` and other inputs to 0 then generate witness. No need to modify the witness.",
        "Proposed Mitigation": "Implement range check so that attacker can't exploit overflow in `LessThan`.",
        "Similar Bugs": [
            "darkforest-eth/darkforest-v0.3/daira_hopwood_darkforest_v0_3_missing_bit_length_check"
        ],
        "title": "Missing Range Checks on Comparison Circuits"
    },
    {
        "Id": "Unirep/Unirep/veridise-V-UNI-VUL-001",
        "Path": "dataset/circom/Unirep/Unirep/veridise_underconstrained_circuit_allows_invalid_comparison",
        "Project": "https://github.com/Unirep/Unirep",
        "Commit": "0985a28c38c8b2e7b7a9e80f43e63179fdd08b89",
        "Fix Commit": "3348caa362d5d632d29c532ffa88023d55628eab",
        "DSL": "Circom",
        "Vulnerability": "Under-Constrained",
        "Impact": "Soundness",
        "Root Cause": "Arithmetic Field Issues",
        "Reproduced": true,
        "Location": {
            "Path": "circuits/bigComparators.circom",
            "Function": "BigLessThan",
            "Line": "45"
        },
        "Source": {
            "Audit Report": {
                "Source Link": "https://github.com/zksecurity/zkbugs/blob/main/reports/documents/veridise-unirep.pdf",
                "Bug ID": "V-UNI-VUL-001: Underconstrained Circuit allows Invalid Comparison"
            }
        },
        "Commands": {
            "Setup Environment": "./zkbugs_setup.sh",
            "Reproduce": "./zkbugs_exploit.sh",
            "Compile and Preprocess": "./zkbugs_compile_setup.sh",
            "Positive Test": "./zkbugs_positive_test.sh",
            "Find Exploit": "./zkbugs_find_exploit.sh",
            "Clean": "./zkbugs_clean.sh"
        },
        "Short Description of the Vulnerability": "`Num2Bits(254)` is used so malicious prover can provide input that is larger than scalar field modulus `p` but smaller than `2**254`, exploiting the overflow. That makes some comparison opertions invalid, for example, `1 < p` evaluates to true but in the circuit it is treated as `1 < 0`.",
        "Short Description of the Exploit": "Set `in[0]` to 1 and `in[1]` to `p`, then generate the witness from inputs directly, no need to modify the witness.",
        "Proposed Mitigation": "Use `Num2Bits_strict` rather than `Num2Bits(254)`.",
        "Similar Bugs": [],
        "title": "Underconstrained Circuit allows Invalid Comparison"
    },
    {
        "Id": "darkforest-eth/darkforest-v0.3/Daira-Hopwood-Missing-Bit-Length-Check",
        "Path": "dataset/circom/darkforest-eth/darkforest-v0.3/daira_hopwood_darkforest_v0_3_missing_bit_length_check",
        "Project": "https://github.com/darkforest-eth/darkforest-v0.3",
        "Commit": "1c83685e22e0463d5481c83e21616745b3204c9c",
        "Fix Commit": "https://github.com/darkforest-eth/circuits/commit/1b5c8440a487614d4a3e6ed523df0aee71a05b6e#diff-440e6bdf86d42398f40d29b9df0b9e6992c6859194d2a7f3c8c68fb46d0f2040",
        "DSL": "Circom",
        "Vulnerability": "Under-Constrained",
        "Impact": "Soundness",
        "Root Cause": "Unsafe Reuse of Circuit",
        "Reproduced": true,
        "Location": {
            "Path": "circuits/range_proof/circuit.circom",
            "Function": "RangeProof",
            "Line": "16-22"
        },
        "Source": {
            "Bug Tracker": {
                "Source Link": "https://github.com/0xPARC/zk-bug-tracker",
                "Bug ID": "Dark Forest v0.3: Missing Bit Length Check"
            }
        },
        "Commands": {
            "Setup Environment": "./zkbugs_setup.sh",
            "Reproduce": "./zkbugs_exploit.sh",
            "Compile and Preprocess": "./zkbugs_compile_setup.sh",
            "Positive Test": "./zkbugs_positive_test.sh",
            "Find Exploit": "./zkbugs_find_exploit.sh",
            "Clean": "./zkbugs_clean.sh"
        },
        "Short Description of the Vulnerability": "Input of `LessThan(bits)` is assumed to take inputs bounded by `2**(bits-1)`, but there is no constraint for it in `LessThan` template. Attacker can use unexpected values outside the range and pass all the constraints, rendering this RangeProof useless. Note: The original circuit does not contain the output `out`, it was added to prevent snarkJS 'Scalar size does not match' error.",
        "Short Description of the Exploit": "Set `in = -255` then generate witness. No need to modify the witness.",
        "Proposed Mitigation": "Add constraints to check the range of `in` and `max_abs_value`. This can be done using the `Num2Bits` template.",
        "Similar Bugs": [
            "Unirep/Unirep/veridise_missing_range_checks_on_comparison_circuits"
        ],
        "title": "Dark Forest v0.3: Missing Bit Length Check"
    },
    {
        "Id": "selfxyz/self/zksecurity_missing_byte_range_checks_allows_packed_data_pollution",
        "Project": "https://github.com/selfxyz/self",
        "Commit": "3905a30aeb19016d22c5493b8b34ade2d118da4e",
        "Fix Commit": "285f0a9776514c1f03f546d1a03a4da588ba098d",
        "DSL": "Circom",
        "Vulnerability": "Under-Constrained",
        "Impact": "Soundness",
        "Root Cause": "Wrong Translation of Logic into Constraints",
        "Reproduced": true,
        "Location": {
            "Path": "circuits/circuits/disclose/vc_and_disclose_aadhaar.circom",
            "Function": "VC_AND_DISCLOSE_Aadhaar",
            "Line": "41-198"
        },
        "Source": {
            "Audit Report": {
                "Source Link": "https://github.com/zksecurity/zkbugs/blob/main/reports/documents/zksecurity-self-aadhaar-circuits.pdf",
                "Bug ID": "#02 - Missing Byte Range Checks Allows Packed Data Pollution"
            }
        },
        "Commands": {
            "Setup Environment": "./zkbugs_setup.sh",
            "Reproduce": "./zkbugs_exploit.sh",
            "Compile and Preprocess": "./zkbugs_compile_setup.sh",
            "Positive Test": "./zkbugs_positive_test.sh",
            "Find Exploit": "./zkbugs_find_exploit.sh",
            "Clean": "./zkbugs_clean.sh"
        },
        "Short Description of the Vulnerability": "`PackBytes` is used to pack the revealed data bytes. The template does not constrain each provided input value to be a byte, i.e. in the range [0, 2^8). This allows crafting inputs exceeding 255.",
        "Short Description of the Exploit": "Using a “negative” (large and close to the modulus) `minimumAge` enables pollution of the final packed output segment (bytes 93–118) that is expected to encode: part of the state, the last 4 digits of the phone number, OFAC result bits, and `minimumAge`.",
        "Proposed Mitigation": "Add an explicit range check using `Num2Bits(8)`, ensuring `minimumAge` is constrained to a byte",
        "title": "Missing Byte Range Checks Allows Packed Data Pollution"
    },
    {
        "Id": "selfxyz/self/zksecurity_missing_boolean_constraints_in_the_merkle_tree_path_leads_to_an_attacker_being_able_to_craft_a_fake_merkle_proof_for_an_arbitrary_leaf",
        "Project": "https://github.com/selfxyz/self",
        "Commit": "4f18c75041bb47c1862169eef82c22067642a83a",
        "Fix Commit": "8801c6c1d793896a778c4b597531bc710995d30c",
        "DSL": "Circom",
        "Vulnerability": "Under-Constrained",
        "Impact": "Soundness",
        "Root Cause": "Wrong Translation of Logic into Constraints",
        "Reproduced": true,
        "Location": {
            "Path": "circuits/circuits/utils/crypto/merkle-trees/smt.circom",
            "Function": "BinaryMerkleRoot",
            "Line": "57-59"
        },
        "Source": {
            "Audit Report": {
                "Source Link": "https://github.com/zksecurity/zkbugs/blob/main/reports/documents/zksecurity-celo-self-audit-2.pdf",
                "Bug ID": "#02 - Missing boolean constraints in the Merkle tree path leads to an attacker being able to craft a fake Merkle proof for an arbitrary leaf"
            }
        },
        "Commands": {
            "Setup Environment": "./zkbugs_setup.sh",
            "Reproduce": "./zkbugs_exploit.sh",
            "Compile and Preprocess": "./zkbugs_compile_setup.sh",
            "Positive Test": "./zkbugs_positive_test.sh",
            "Find Exploit": "./zkbugs_find_exploit.sh",
            "Clean": "./zkbugs_clean.sh"
        },
        "Short Description of the Vulnerability": "The `BinaryMerkleRoot` template is used in multiple places in the circuits to recover the root of a binary Merkle tree. Notice that this template does not enforce any boolean constraints on the `indices` array. As a result of this issue, an attacker can craft a fake Merkle proof for any leaf value of their choosing. Since the Merkle tree is used to perform multiple checks throughout the circuits, this means that the attacker can bypass any check that relies on a Merkle proof, for example the inclusion of the CSCA and DSC certificates in the certificates trees.",
        "Short Description of the Exploit": "An attacker can craft fake Merkle proofs for any leaf value of their choosing by carefully constructing the `indices` and `siblings` array such that the input to the Poseidon call matches a real leaf pair.",
        "Proposed Mitigation": "We recommend adding boolean constraints to the `indices` array in the `BinaryMerkleRoot` template.",
        "title": "Missing boolean constraints in the Merkle tree path leads to an attacker being able to craft a fake Merkle proof for an arbitrary leaf"
    },
    {
        "Id": "selfxyz/self/zksecurity_an_attacker_can_craft_a_fake_non_inclusion_proof_for_a_given_key_due_to_an_aliasing_bug_in_the_smt_verifier",
        "Project": "https://github.com/selfxyz/self",
        "Commit": "4f18c75041bb47c1862169eef82c22067642a83a",
        "Fix Commit": "99e8eece5e0867017ca076731fba63ed96ae4711",
        "DSL": "Circom",
        "Vulnerability": "Under-Constrained",
        "Impact": "Soundness",
        "Root Cause": "Wrong Translation of Logic into Constraints",
        "Reproduced": true,
        "Location": {
            "Path": "circuits/circuits/utils/crypto/merkle-trees/smt.circom",
            "Function": "SMTVerify",
            "Line": "18-67"
        },
        "Source": {
            "Audit Report": {
                "Source Link": "https://github.com/zksecurity/zkbugs/blob/main/reports/documents/zksecurity-celo-self-audit-2.pdf",
                "Bug ID": "#00 - An attacker can craft a fake non-inclusion proof for a given key due to an aliasing bug in the SMT verifier"
            }
        },
        "Commands": {
            "Setup Environment": "./zkbugs_setup.sh",
            "Reproduce": "./zkbugs_exploit.sh",
            "Compile and Preprocess": "./zkbugs_compile_setup.sh",
            "Positive Test": "./zkbugs_positive_test.sh",
            "Find Exploit": "./zkbugs_find_exploit.sh",
            "Clean": "./zkbugs_clean.sh"
        },
        "Short Description of the Vulnerability": "The `Num2Bits(254)` component presents an aliasing issue. The Num2Bits circuit in circomlib, witnesses the binary representation in the `out` array, and then checks that the recomposed value matches the input `in`. This computation is done modulo the field size, which is smaller than 2^254. Therefore, for approximately a quarter of the possible keys, an attacker can witness a different binary representation of the key.",
        "Short Description of the Exploit": "If the original key is k and the field prime is p, if k < 2^254 - p the attacker can witness the binary representation of k + p, which will be accepted by the circuit. However, this new representation will not be equal to the original key’s representation, and the new path that will be checked by the circuit will be different. This means that an attacker can craft a fake non-inclusion proof for a key which is present in the tree, by just opening the leaf corresponding to the position of k + p instead of k.",
        "Proposed Mitigation": "We recommend replacing the `Num2Bits` component with `Num2Bits_strict`, which does not have the aliasing issue.",
        "title": "An attacker can craft a fake non-inclusion proof for a given key due to an aliasing bug in the SMT verifier"
    },
    {
        "Id": "selfxyz/self/zksecurity_second_pre_image_attacks_on_packbytesandposeidon_may_be_used_to_register_arbitrary_passports_and_dsc_certificates",
        "Project": "https://github.com/selfxyz/self",
        "Commit": "629dfdad1a867eb82ccba6857a545f3ef838e123",
        "Fix Commit": "",
        "DSL": "Circom",
        "Vulnerability": "Under-Constrained",
        "Impact": "Soundness",
        "Root Cause": "Missing Input Constraints",
        "Reproduced": true,
        "Location": {
            "Path": "circuits/circuits/utils/passport/customHashers.circom",
            "Function": "PackBytesAndPoseidon",
            "Line": "54-60"
        },
        "Source": {
            "Audit Report": {
                "Source Link": "https://github.com/zksecurity/zkbugs/blob/main/reports/documents/zksecurity-self-aadhaar-circuits.pdf",
                "Bug ID": "#01 - Second Pre-Image Attacks On PackBytesAndPoseidon May Be Used To Register Arbitrary Passports And DSC Certificates"
            }
        },
        "Commands": {
            "Setup Environment": "./zkbugs_setup.sh",
            "Reproduce": "./zkbugs_exploit.sh",
            "Compile and Preprocess": "./zkbugs_compile_setup.sh",
            "Positive Test": "./zkbugs_positive_test.sh",
            "Find Exploit": "./zkbugs_find_exploit.sh",
            "Clean": "./zkbugs_clean.sh"
        },
        "Short Description of the Vulnerability": "The function `PackBytesAndPoseidon(k)` in CustomHashers.circom is susceptible to a second pre-image attack: given an input x, an input y can be found such that `PackBytesAndPoseidon(k)(x) == PackBytesAndPoseidon(k)(y)` where y is not an array of bytes, but an array of arbitrary field elements. For example consider [0, 1, 0] and [256, 0, 0] they both compute [256] as an intermediate value (output of PackBytes bytes.circom). This intermediate value is later passed to the `CustomHasher` function: because the intermediate value is identical, both inputs will yield the same hash.",
        "Short Description of the Exploit": "This is a serious vulnerability because, although it is not possible for an attacker to modify all bytes of a key, given that some bytes outside the key are needed to preserve the hash collision, using this technique an attacker could modify up to 30 bytes of the original public key and search for a new public key he can factorize to sign an arbitrary passport. Similarly he could freely modify up to 30 bytes of an ECDSA key (which could be as small as 56 bytes for brainpool224) to achieve a similar goal of computing a corresponding valid private key.",
        "Proposed Mitigation": "We recommend that the ranges of the bytes array are checked inside `PackBytesAndPoseidon`.",
        "title": "Second Pre-Image Attacks On PackBytesAndPoseidon May Be Used To Register Arbitrary Passports And DSC Certificates"
    },
    {
        "Id": "selfxyz/self/zksecurity_big_integer_zero_check_is_not_sound",
        "Project": "https://github.com/selfxyz/self",
        "Commit": "",
        "Fix Commit": "",
        "DSL": "Circom",
        "Vulnerability": "Computational Issues",
        "Impact": "Soundness",
        "Root Cause": "Wrong Translation of Logic into Constraints",
        "Reproduced": true,
        "Location": {
            "Path": "",
            "Function": "BigIntIsZero",
            "Line": "05-26"
        },
        "Source": {
            "Audit Report": {
                "Source Link": "https://github.com/zksecurity/zkbugs/blob/main/reports/documents/zksecurity-celo-self-audit.pdf",
                "Bug ID": "#02 - Big Integer Zero-Check Is Not Sound"
            }
        },
        "Commands": {
            "Setup Environment": "./zkbugs_setup.sh",
            "Reproduce": "./zkbugs_exploit.sh",
            "Compile and Preprocess": "./zkbugs_compile_setup.sh",
            "Positive Test": "./zkbugs_positive_test.sh",
            "Find Exploit": "./zkbugs_find_exploit.sh",
            "Clean": "./zkbugs_clean.sh"
        },
        "Short Description of the Vulnerability": "One of the core operation that is used throughout the big integer implementation is the assertion for a zero element. It is implemented in the template `BigIntIsZero` and is used in multiple places in the library. It does so by first accumulating the carries, then range checking the final carry value and then asserting that the final carry is the opposite of the most significant chunk. However, the accumulation of the carries is performed over the native field, so the entire relation is checked modulo the Circom native prime. This bug does not compromise completeness, as the zero integer will still be considered as zero modulo the native prime. However, this check is not sound, as a non-zero integer, which is zero mod native prime, will be considered zero by the library.",
        "Short Description of the Exploit": "To show an exploit, we provide an input to check if a point is on the elliptic curve, which satisfies the constraints but is not a valid point on the curve. To assert that a point (x, y) lies on a curve, the circuits computes Z = y^2 - x^3 - a * x - b and then it asserts that Z = 0 mod p, which internally uses BigIntIsZero. To make this check pass with an invalid point, it suffices to find a pair of coordinates that satisfy the curve equation modulo the Circom prime, but not modulo the curve prime p.",
        "Proposed Mitigation": " It is recommended that the Big Integer Library used for ECDSA Verification is either carefully reviewed for such issues and fixed, or it is replaced by a more mature implementation.",
        "title": "Big Integer Zero-Check Is Not Sound"
    },
    {
        "Id": "selfxyz/self/zksecurity_the_registration_and_disclosure_circuits_lack_range_checks_for_the_input_indices",
        "Project": "https://github.com/selfxyz/self",
        "Commit": "4f18c75041bb47c1862169eef82c22067642a83a",
        "Fix Commit": "49de54966e40709ac59d4070fd4bd0279b2a10c0",
        "DSL": "Circom",
        "Vulnerability": "Under-Constrained",
        "Impact": "Soundness",
        "Root Cause": "Wrong Translation of Logic into Constraints",
        "Reproduced": true,
        "Location": {
            "Path": "circuits/circuits/register_id/register_id.circom",
            "Function": "REGISTER_ID",
            "Line": "101-105"
        },
        "Source": {
            "Audit Report": {
                "Source Link": "https://github.com/zksecurity/zkbugs/blob/main/reports/documents/zksecurity-celo-self-audit-2.pdf",
                "Bug ID": "#03 - The registration and disclosure circuits lack range checks for the input indices"
            }
        },
        "Commands": {
            "Setup Environment": "./zkbugs_setup.sh",
            "Reproduce": "./zkbugs_exploit.sh",
            "Compile and Preprocess": "./zkbugs_compile_setup.sh",
            "Positive Test": "./zkbugs_positive_test.sh",
            "Find Exploit": "./zkbugs_find_exploit.sh",
            "Clean": "./zkbugs_clean.sh"
        },
        "Short Description of the Vulnerability": "There are actually two separate issues with this code. (1) The computation `dsc_pubKey_offset + dsc_pubKey_actual_size` could overflow or underflow the field, leading to a wrong check semantics. (2) The `LessEqThan` template checks that the first input is less than or equal to the second input, but it assumes that both of the inputs are between 0 and 2^{12} - 1. If this is not the case, the circuit will produce some unexpected behaviour, as for example `LessEqThan(12)` with input values p - 1 and 0 will return 1 instead of 0. In this context, the intended range of the indices is to be between 0 and 2^{12} - 1, so this check could pass even if the indices are outside this range, leading to unexpected behaviour in the circuit.",
        "Short Description of the Exploit": "An attacker can provide incorrect indices to the circuit, for example negative indices, which pass the range checks. We could not find any concrete exploit, as incorrect indices make the proof fail in subsequent checks. However, they can lead to unexpected behaviour in the circuits, if for example some other circuits rely on the fact that indices are in the correct range.",
        "Proposed Mitigation": "We recommend to ensure that every computation done with indices does not overflow or underflow the field, by adding additional range checks. Additionally, we recommend to add range checks to the input signals of the `LessEqThan` template, to ensure that there is no unexpected behaviour when the inputs are outside the intended range.",
        "title": "The registration and disclosure circuits lack range checks for the input indices"
    },
    {
        "Id": "selfxyz/self/zksecurity_forbidden_country_check_bypass_via_packed_byte_overflow",
        "Project": "https://github.com/selfxyz/self",
        "Commit": "3905a30aeb19016d22c5493b8b34ade2d118da4e",
        "Fix Commit": [
            "60501d17ee9b339e36c3a2a0d63f24bda65110a8",
            "4914074d11d1d6e4579c7fa4d20c0eae4fc1e02f"
        ],
        "DSL": "Circom",
        "Vulnerability": "Under-Constrained",
        "Impact": "Soundness",
        "Root Cause": "Wrong Translation of Logic into Constraints",
        "Reproduced": true,
        "Location": {
            "Path": "circuits/circuits/utils/aadhaar/disclose/country_not_in_list.circom",
            "Function": "CountryNotInList",
            "Line": "12-29"
        },
        "Source": {
            "Audit Report": {
                "Source Link": "https://github.com/zksecurity/zkbugs/blob/main/reports/documents/zksecurity-self-aadhaar-circuits.pdf",
                "Bug ID": "#00 - Forbidden Country Check Bypass via Packed Byte Overflow"
            }
        },
        "Commands": {
            "Setup Environment": "./zkbugs_setup.sh",
            "Reproduce": "./zkbugs_exploit.sh",
            "Compile and Preprocess": "./zkbugs_compile_setup.sh",
            "Positive Test": "./zkbugs_positive_test.sh",
            "Find Exploit": "./zkbugs_find_exploit.sh",
            "Clean": "./zkbugs_clean.sh"
        },
        "Short Description of the Vulnerability": "The elements of `forbidden_countries_list` are not range‑checked to be bytes, which means PackBytes allows for aliasing.",
        "Short Description of the Exploit": "By omitting range checks on forbidden_countries_list, an attacker can supply out‑of‑range values (e.g. >255) so per‑byte equality checks with the user’s 3‑byte code fail while PackBytes produces packed integers that decode to the forbidden country, allowing the check to be bypassed.",
        "Proposed Mitigation": "Add explicit byte range constraints, for example using `AssertBytes`, on every country code element before passing them to `PackBytes` in `CountryNotInList`.",
        "title": "Forbidden Country Check Bypass via Packed Byte Overflow"
    },
    {
        "Id": "selfxyz/self/zksecurity_exclusion_check_of_forbidden_countries_is_unsound_and_incomplete_due_to_incorrect_indexing",
        "Project": "https://github.com/selfxyz/self",
        "Commit": "59c16d6e924c946970665504d883ced46981e5c1",
        "Fix Commit": "",
        "DSL": "Circom",
        "Vulnerability": "Computational Issues",
        "Impact": "Soundness and Completeness",
        "Root Cause": "Wrong Translation of Logic into Constraints",
        "Reproduced": true,
        "Location": {
            "Path": "circuits/circuits/utils/passport/disclose/proveCountryIsNotInList.circom",
            "Function": "ProveCountryIsNotInList",
            "Line": "12-18"
        },
        "Source": {
            "Audit Report": {
                "Source Link": "https://github.com/zksecurity/zkbugs/blob/main/reports/documents/zksecurity-celo-self-audit.pdf",
                "Bug ID": "#00 - Exclusion Check Of Forbidden Countries Is Unsound And Incomplete Due To Incorrect Indexing"
            }
        },
        "Commands": {
            "Setup Environment": "./zkbugs_setup.sh",
            "Reproduce": "./zkbugs_exploit.sh",
            "Compile and Preprocess": "./zkbugs_compile_setup.sh",
            "Positive Test": "./zkbugs_positive_test.sh",
            "Find Exploit": "./zkbugs_find_exploit.sh",
            "Clean": "./zkbugs_clean.sh"
        },
        "Short Description of the Vulnerability": "The `ProveCountryIsNotInList` check is performed by iterating over forbidden countries entry and comparing each letter individually for equality. However, the index `i` that is used to loop over the forbidden countries list is incorrect, as it should loop over `i * 3` instead.",
        "Short Description of the Exploit": "This issue breaks both soundness and completeness as demonstrated by the following examples: - **Unsound**: let `MAX_FORBIDDEN_COUNTRIES_LIST_LENGTH = 3` and `forbidden_countries_list = ['ABC','DEF','GHI']`, then someone with the passport from `GHI` country will pass the check because the loop will stop at `i = 3`. - **Incomplete**: let `forbidden_countries_list = ['ABC','DEF']`, then someone with the passport from `BCD` country will not pass the check because the loop will also check over `i = 2`, `i = 3`, and `i = 4`.",
        "Proposed Mitigation": "Update the indexing of `forbidden_countries_list` to use `i*3`.",
        "title": "Exclusion Check Of Forbidden Countries Is Unsound And Incomplete Due To Incorrect Indexing"
    },
    {
        "Id": "iden3/circomlib/veridise-V-CIRCOMLIB-VUL-004",
        "Path": "dataset/circom/iden3/circomlib/veridise_underconstrained_points_in_montgomeryAdd",
        "Project": "https://github.com/iden3/circomlib",
        "Commit": "cff5ab6288b55ef23602221694a6a38a0239dcc0",
        "Fix Commit": "",
        "DSL": "Circom",
        "Vulnerability": "Under-Constrained",
        "Impact": "Soundness",
        "Root Cause": "Missing Input Constraints",
        "Reproduced": true,
        "Location": {
            "Path": "circuits/montgomery.circom",
            "Function": "MontgomeryAdd",
            "Line": "16-17"
        },
        "Source": {
            "Audit Report": {
                "Source Link": "https://github.com/zksecurity/zkbugs/blob/main/reports/documents/veridise-circomlib.pdf",
                "Bug ID": "V-CIRCOMLIB-VUL-004: Underconstrained points in MontgomeryAdd"
            }
        },
        "Commands": {
            "Setup Environment": "./zkbugs_setup.sh",
            "Reproduce": "./zkbugs_exploit.sh",
            "Compile and Preprocess": "./zkbugs_compile_setup.sh",
            "Positive Test": "./zkbugs_positive_test.sh",
            "Find Exploit": "./zkbugs_find_exploit.sh",
            "Clean": "./zkbugs_clean.sh"
        },
        "Short Description of the Vulnerability": "Lambda calculation involves a division but there is no constraint on the divisor to be non-zero. In this case `out[1]` is underconstrained and can be set to any value.",
        "Short Description of the Exploit": "Set `out[0]` to -168697. `out[1]` can be set to any value but it has to satisfy some relative relation with `in1[1]` and `in2[1]`. Check out `detect.sage` to learn more.",
        "Proposed Mitigation": "Send `in2[0] - in1[0]` to `isZero` template and let the constraint there do the work.",
        "Similar Bugs": [
            "iden3/circomlib/veridise_decoder_accepting_bogus_output_signal",
            "iden3/circomlib/veridise_underconstrained_outputs_in_bitElementMulAny",
            "iden3/circomlib/veridise_underconstrained_points_in_edwards2Montgomery",
            "iden3/circomlib/veridise_underconstrained_points_in_montgomery2Edwards",
            "iden3/circomlib/veridise_underconstrained_points_in_montgomeryDouble"
        ],
        "title": "Underconstrained points in MontgomeryAdd"
    },
    {
        "Id": "iden3/circomlib/veridise-V-CIRCOMLIB-VUL-006",
        "Path": "dataset/circom/iden3/circomlib/veridise_underconstrained_outputs_in_bitElementMulAny",
        "Project": "https://github.com/iden3/circomlib",
        "Commit": "cff5ab6288b55ef23602221694a6a38a0239dcc0",
        "Fix Commit": "",
        "DSL": "Circom",
        "Vulnerability": "Under-Constrained",
        "Impact": "Soundness",
        "Root Cause": "Unsafe Reuse of Circuit",
        "Reproduced": true,
        "Location": {
            "Path": "circuits/escalarmulany.circom",
            "Function": "BitElementMulAny",
            "Line": "21-22"
        },
        "Source": {
            "Audit Report": {
                "Source Link": "https://github.com/zksecurity/zkbugs/blob/main/reports/documents/veridise-circomlib.pdf",
                "Bug ID": "V-CIRCOMLIB-VUL-006: Underconstrained outputs in BitElementMulAny"
            }
        },
        "Commands": {
            "Setup Environment": "./zkbugs_setup.sh",
            "Reproduce": "./zkbugs_exploit.sh",
            "Compile and Preprocess": "./zkbugs_compile_setup.sh",
            "Positive Test": "./zkbugs_positive_test.sh",
            "Find Exploit": "./zkbugs_find_exploit.sh",
            "Clean": "./zkbugs_clean.sh"
        },
        "Short Description of the Vulnerability": "`BitElementMulAny` template itself is fine, but it uses `MontgomeryDouble` and `MontgomeryAdd`, which have underconstraint bugs. With the same `input.json`, malicious prover can manipulate lambda value in `MontgomeryDouble` to let the circuit produce different outputs, making it nondeterministic.",
        "Short Description of the Exploit": "In input.json, just use dummy EC point (1,2) to pass the positive test. Then we exploit the `MontgomeryDouble` underconstrained bug, let divisor be 0 and solve for the exploitable witness in sagemath step by step.",
        "Proposed Mitigation": "Fix underconstraint bugs in `MontgomeryDouble` and `MontgomeryAdd`.",
        "Similar Bugs": [
            "iden3/circomlib/veridise_decoder_accepting_bogus_output_signal",
            "iden3/circomlib/veridise_underconstrained_points_in_edwards2Montgomery",
            "iden3/circomlib/veridise_underconstrained_points_in_montgomery2Edwards",
            "iden3/circomlib/veridise_underconstrained_points_in_montgomeryAdd",
            "iden3/circomlib/veridise_underconstrained_points_in_montgomeryDouble"
        ],
        "title": "Underconstrained outputs in BitElementMulAny"
    },
    {
        "Id": "iden3/circomlib/veridise-V-CIRCOMLIB-VUL-005",
        "Path": "dataset/circom/iden3/circomlib/veridise_underconstrained_points_in_montgomeryDouble",
        "Project": "https://github.com/iden3/circomlib",
        "Commit": "cff5ab6288b55ef23602221694a6a38a0239dcc0",
        "Fix Commit": "",
        "DSL": "Circom",
        "Vulnerability": "Under-Constrained",
        "Impact": "Soundness",
        "Root Cause": "Missing Input Constraints",
        "Reproduced": true,
        "Location": {
            "Path": "circuits/montgomery.circom",
            "Function": "MontgomeryDouble",
            "Line": "18-19"
        },
        "Source": {
            "Audit Report": {
                "Source Link": "https://github.com/zksecurity/zkbugs/blob/main/reports/documents/veridise-circomlib.pdf",
                "Bug ID": "V-CIRCOMLIB-VUL-005: Underconstrained points in MontgomeryDouble"
            }
        },
        "Commands": {
            "Setup Environment": "./zkbugs_setup.sh",
            "Reproduce": "./zkbugs_exploit.sh",
            "Compile and Preprocess": "./zkbugs_compile_setup.sh",
            "Positive Test": "./zkbugs_positive_test.sh",
            "Find Exploit": "./zkbugs_find_exploit.sh",
            "Clean": "./zkbugs_clean.sh"
        },
        "Short Description of the Vulnerability": "Lambda calculation involves a division but there is no constraint on the divisor to be non-zero. In this case `lamda` is underconstrained and can be set to any value.",
        "Short Description of the Exploit": "Set `in[1]` to 0. Make the assumption that `3*x1_2 + 2*A*in[0] + 1 == 0` and solve for rest of the signals with some sagemath magic.",
        "Proposed Mitigation": "Send `in[1]` to `isZero` template and let the constraint there do the work.",
        "Similar Bugs": [
            "iden3/circomlib/veridise_decoder_accepting_bogus_output_signal",
            "iden3/circomlib/veridise_underconstrained_outputs_in_bitElementMulAny",
            "iden3/circomlib/veridise_underconstrained_points_in_edwards2Montgomery",
            "iden3/circomlib/veridise_underconstrained_points_in_montgomery2Edwards",
            "iden3/circomlib/veridise_underconstrained_points_in_montgomeryAdd"
        ],
        "title": "Underconstrained points in MontgomeryDouble"
    },
    {
        "Id": "iden3/circomlib/veridise-V-CIRCOMLIB-VUL-001",
        "Path": "dataset/circom/iden3/circomlib/veridise_decoder_accepting_bogus_output_signal",
        "Project": "https://github.com/iden3/circomlib",
        "Commit": "cff5ab6288b55ef23602221694a6a38a0239dcc0",
        "Fix Commit": "",
        "DSL": "Circom",
        "Vulnerability": "Under-Constrained",
        "Impact": "Soundness",
        "Root Cause": "Wrong Translation of Logic into Constraints",
        "Reproduced": true,
        "Location": {
            "Path": "circuits/multiplexer.circom",
            "Function": "Decoder",
            "Line": "10-11"
        },
        "Source": {
            "Audit Report": {
                "Source Link": "https://github.com/zksecurity/zkbugs/blob/main/reports/documents/veridise-circomlib.pdf",
                "Bug ID": "V-CIRCOMLIB-VUL-001: Decoder accepting bogus output signal"
            }
        },
        "Commands": {
            "Setup Environment": "./zkbugs_setup.sh",
            "Reproduce": "./zkbugs_exploit.sh",
            "Compile and Preprocess": "./zkbugs_compile_setup.sh",
            "Positive Test": "./zkbugs_positive_test.sh",
            "Find Exploit": "./zkbugs_find_exploit.sh",
            "Clean": "./zkbugs_clean.sh"
        },
        "Short Description of the Vulnerability": "The circuit does not constrain `out` properly, malicious prover can set a bogus `out` and set `success` to 0, the circuit won't throw error. This makes integration error-prone.",
        "Short Description of the Exploit": "Set `out` to be full of zeroes and set `success` to 0.",
        "Proposed Mitigation": "Send `inp - i` to `isZero` template and let the constraint there do the work.",
        "Similar Bugs": [
            "iden3/circomlib/veridise_underconstrained_outputs_in_bitElementMulAny",
            "iden3/circomlib/veridise_underconstrained_points_in_edwards2Montgomery",
            "iden3/circomlib/veridise_underconstrained_points_in_montgomery2Edwards",
            "iden3/circomlib/veridise_underconstrained_points_in_montgomeryAdd",
            "iden3/circomlib/veridise_underconstrained_points_in_montgomeryDouble"
        ],
        "title": "Decoder accepting bogus output signal"
    },
    {
        "Id": "iden3/circomlib/veridise-V-CIRCOMLIB-VUL-008",
        "Path": "dataset/circom/iden3/circomlib/veridise_underconstrained_outputs_in_windowmulfix",
        "Project": "https://github.com/iden3/circomlib",
        "Commit": "cff5ab6288b55ef23602221694a6a38a0239dcc0",
        "Fix Commit": "",
        "DSL": "Circom",
        "Vulnerability": "Under-Constrained",
        "Impact": "Soundness",
        "Root Cause": "Unsafe Reuse of Circuit",
        "Reproduced": true,
        "Location": {
            "Path": "circuits/escalarmulfix.circom",
            "Function": "WindowMulFix",
            "Line": "70-131"
        },
        "Source": {
            "Audit Report": {
                "Source Link": "https://github.com/zksecurity/zkbugs/blob/main/reports/documents/veridise-circomlib.pdf",
                "Bug ID": "V-CIRCOMLIB-VUL-008: Underconstrained outputs in WindowMulFix"
            }
        },
        "Commands": {
            "Setup Environment": "./zkbugs_setup.sh",
            "Reproduce": "./zkbugs_exploit.sh",
            "Compile and Preprocess": "./zkbugs_compile_setup.sh",
            "Positive Test": "./zkbugs_positive_test.sh",
            "Find Exploit": "./zkbugs_find_exploit.sh",
            "Clean": "./zkbugs_clean.sh"
        },
        "Short Description of the Vulnerability": "`WindowMulFix` template itself is fine, but it uses `MontgomeryDouble` and `MontgomeryAdd`, which have underconstraint bugs. With the same `input.json`, malicious prover can manipulate lambda value in `MontgomeryDouble` to let the circuit produce different outputs, making it nondeterministic.",
        "Short Description of the Exploit": "Here we exploit the `MontgomeryDouble` underconstrained bug, let divisor be 0 and solve for signals in sagemath step by step. The full witness is provided in veridise report.",
        "Proposed Mitigation": "Fix underconstraint bugs in `MontgomeryDouble` and `MontgomeryAdd`.",
        "title": "Underconstrained outputs in WindowMulFix"
    },
    {
        "Id": "iden3/circomlib/veridise-V-CIRCOMLIB-VUL-007",
        "Path": "dataset/circom/iden3/circomlib/veridise_underconstrained_outputs_in_window4",
        "Project": "https://github.com/iden3/circomlib",
        "Commit": "cff5ab6288b55ef23602221694a6a38a0239dcc0",
        "Fix Commit": "",
        "DSL": "Circom",
        "Vulnerability": "Under-Constrained",
        "Impact": "Soundness",
        "Root Cause": "Unsafe Reuse of Circuit",
        "Reproduced": true,
        "Location": {
            "Path": "circuits/pederson.circom",
            "Function": "Window4",
            "Line": "47-108"
        },
        "Source": {
            "Audit Report": {
                "Source Link": "https://github.com/zksecurity/zkbugs/blob/main/reports/documents/veridise-circomlib.pdf",
                "Bug ID": "V-CIRCOMLIB-VUL-007: Underconstrained outputs in Window4"
            }
        },
        "Commands": {
            "Setup Environment": "./zkbugs_setup.sh",
            "Reproduce": "./zkbugs_exploit.sh",
            "Compile and Preprocess": "./zkbugs_compile_setup.sh",
            "Positive Test": "./zkbugs_positive_test.sh",
            "Find Exploit": "./zkbugs_find_exploit.sh",
            "Clean": "./zkbugs_clean.sh"
        },
        "Short Description of the Vulnerability": "`Window4` template itself is fine, but it uses `MontgomeryDouble` and `MontgomeryAdd`, which have underconstraint bugs. With the same `input.json`, malicious prover can manipulate lambda value in `MontgomeryDouble` to let the circuit produce different outputs, making it nondeterministic.",
        "Short Description of the Exploit": "Here we exploit the `MontgomeryDouble` underconstrained bug, let divisor be 0 and solve for signals in sagemath step by step. The full witness is provided in veridise report.",
        "Proposed Mitigation": "Fix underconstraint bugs in `MontgomeryDouble` and `MontgomeryAdd`.",
        "title": "Underconstrained outputs in Window4"
    },
    {
        "Id": "iden3/circomlib/veridise-V-CIRCOMLIB-VUL-002",
        "Path": "dataset/circom/iden3/circomlib/veridise_underconstrained_points_in_edwards2Montgomery",
        "Project": "https://github.com/iden3/circomlib",
        "Commit": "cff5ab6288b55ef23602221694a6a38a0239dcc0",
        "Fix Commit": "",
        "DSL": "Circom",
        "Vulnerability": "Under-Constrained",
        "Impact": "Soundness",
        "Root Cause": "Missing Input Constraints",
        "Reproduced": true,
        "Location": {
            "Path": "circuits/montgomery.circom",
            "Function": "Edwards2Montgomery",
            "Line": "7-8"
        },
        "Source": {
            "Audit Report": {
                "Source Link": "https://github.com/zksecurity/zkbugs/blob/main/reports/documents/veridise-circomlib.pdf",
                "Bug ID": "V-CIRCOMLIB-VUL-002: Underconstrained points in Edwards2Montgomery"
            }
        },
        "Commands": {
            "Setup Environment": "./zkbugs_setup.sh",
            "Reproduce": "./zkbugs_exploit.sh",
            "Compile and Preprocess": "./zkbugs_compile_setup.sh",
            "Positive Test": "./zkbugs_positive_test.sh",
            "Find Exploit": "./zkbugs_find_exploit.sh",
            "Clean": "./zkbugs_clean.sh"
        },
        "Short Description of the Vulnerability": "The circuit does not implement constraint to avoid division by zero. When setting the divisor to 0, `out[1]` is underconstrained and can be set to any value.",
        "Short Description of the Exploit": "Set `in[0]` to 0 to trigger division by zero. Set `out[1]` to 1337 just to show that it can be set to any value.",
        "Proposed Mitigation": "Send `in[0]` and `1 - in[1]` to `isZero` template and let the constraint there do the work.",
        "Similar Bugs": [
            "iden3/circomlib/veridise_decoder_accepting_bogus_output_signal",
            "iden3/circomlib/veridise_underconstrained_outputs_in_bitElementMulAny",
            "iden3/circomlib/veridise_underconstrained_points_in_montgomery2Edwards",
            "iden3/circomlib/veridise_underconstrained_points_in_montgomeryAdd",
            "iden3/circomlib/veridise_underconstrained_points_in_montgomeryDouble"
        ],
        "title": "Underconstrained points in Edwards2Montgomery"
    },
    {
        "Id": "iden3/circomlib/Kobi-Gurkan-MiMC-Hash-Assigned-but-not-Constrained",
        "Path": "dataset/circom/iden3/circomlib/kobi_gurkan_mimc_hash_assigned_but_not_constrained",
        "Project": "https://github.com/iden3/circomlib",
        "Commit": "324b8bf8cc4a80357354752deb6c2ae5be22e5f5",
        "Fix Commit": "109cdf40567fce284dca1d535819ce28922653e0",
        "DSL": "Circom",
        "Vulnerability": "Under-Constrained",
        "Impact": "Soundness",
        "Root Cause": "Assigned but Unconstrained",
        "Reproduced": true,
        "Location": {
            "Path": "circuits/mimcsponge.circom",
            "Function": "MiMCSponge",
            "Line": "28"
        },
        "Source": {
            "Bug Tracker": {
                "Source Link": "https://github.com/0xPARC/zk-bug-tracker?tab=readme-ov-file#14-mimc-hash-assigned-but-not-constrained",
                "Bug ID": "MiMC Hash: Assigned but not Constrained"
            }
        },
        "Commands": {
            "Setup Environment": "./zkbugs_setup.sh",
            "Reproduce": "./zkbugs_exploit.sh",
            "Compile and Preprocess": "./zkbugs_compile_setup.sh",
            "Positive Test": "./zkbugs_positive_test.sh",
            "Find Exploit": "./zkbugs_find_exploit.sh",
            "Clean": "./zkbugs_clean.sh"
        },
        "Short Description of the Vulnerability": "In `MiMCSponge` template, `outs[0]` is assigned but not constrained, so it can be any value. Note that the circuit code is modified from a newer version since the original buggy code couldn't be reproduced in Circom version 2. The bug idea is still the same.",
        "Short Description of the Exploit": "Set `ins[0]` and `k` to any random field element. Generate a correct witness first then modify the 2nd entry to a number as you wish. You can see that `outs[0]` can be any number.",
        "Proposed Mitigation": "Use `<==` instead of `<--` to add a constraint to `outs[0]`.",
        "Similar Bugs": [
            "reclaimprotocol/circom-chacha20/zksecurity_unsound_left_rotation",
            "personaelabs/spartan-ecdsa/yacademy_input_signal_s_is_not_constrained_in_eff_ecdsa_circom"
        ],
        "title": "MiMC Hash: Assigned but not Constrained"
    },
    {
        "Id": "iden3/circomlib/veridise-V-CIRCOMLIB-VUL-003",
        "Path": "dataset/circom/iden3/circomlib/veridise_underconstrained_points_in_montgomery2Edwards",
        "Project": "https://github.com/iden3/circomlib",
        "Commit": "cff5ab6288b55ef23602221694a6a38a0239dcc0",
        "Fix Commit": "",
        "DSL": "Circom",
        "Vulnerability": "Under-Constrained",
        "Impact": "Soundness",
        "Root Cause": "Missing Input Constraints",
        "Reproduced": true,
        "Location": {
            "Path": "circuits/montgomery.circom",
            "Function": "Montgomery2Edwards",
            "Line": "7-8"
        },
        "Source": {
            "Audit Report": {
                "Source Link": "https://github.com/zksecurity/zkbugs/blob/main/reports/documents/veridise-circomlib.pdf",
                "Bug ID": "V-CIRCOMLIB-VUL-003: Underconstrained points in Montgomery2Edwards"
            }
        },
        "Commands": {
            "Setup Environment": "./zkbugs_setup.sh",
            "Reproduce": "./zkbugs_exploit.sh",
            "Compile and Preprocess": "./zkbugs_compile_setup.sh",
            "Positive Test": "./zkbugs_positive_test.sh",
            "Find Exploit": "./zkbugs_find_exploit.sh",
            "Clean": "./zkbugs_clean.sh"
        },
        "Short Description of the Vulnerability": "The circuit does not implement constraint to avoid division by zero. When setting the divisor to 0, `out[0]` is underconstrained and can be set to any value.",
        "Short Description of the Exploit": "Set `in[1]` to 0 to trigger division by zero. Set `out[0]` to 1337 just to show that it can be set to any value.",
        "Proposed Mitigation": "Send `in[1]` and `in[0] + 1` to `isZero` template and let the constraint there do the work.",
        "Similar Bugs": [
            "iden3/circomlib/veridise_decoder_accepting_bogus_output_signal",
            "iden3/circomlib/veridise_underconstrained_outputs_in_bitElementMulAny",
            "iden3/circomlib/veridise_underconstrained_points_in_edwards2Montgomery",
            "iden3/circomlib/veridise_underconstrained_points_in_montgomeryAdd",
            "iden3/circomlib/veridise_underconstrained_points_in_montgomeryDouble"
        ],
        "title": "Underconstrained points in Montgomery2Edwards"
    },
    {
        "Id": "iden3/circuits/trailofbits_unsafe_use_of_num2bits_in_multiple_circuits",
        "Project": "https://github.com/iden3/circuits",
        "Commit": "7a1e04de3e5f3a9f0cfb27a43c9f41c986c1b9ed",
        "Fix Commit": "",
        "DSL": "Circom",
        "Vulnerability": "Under-Constrained",
        "Impact": "Soundness",
        "Root Cause": "Wrong Translation of Logic into Constraints",
        "Reproduced": true,
        "Location": {
            "Path": "circuits/lib/utils/claimUtils.circom",
            "Function": "Num2Bits",
            "Line": "123"
        },
        "Source": {
            "Audit Report": {
                "Source Link": "https://github.com/zksecurity/zkbugs/blob/main/reports/documents/trailofbits-iden3-circuits.pdf",
                "Bug ID": "TOB-IDEN3-1"
            }
        },
        "Commands": {
            "Setup Environment": "./zkbugs_setup.sh",
            "Reproduce": "./zkbugs_exploit.sh",
            "Compile and Preprocess": "./zkbugs_compile_setup.sh",
            "Positive Test": "./zkbugs_positive_test.sh",
            "Find Exploit": "./zkbugs_find_exploit.sh",
            "Clean": "./zkbugs_clean.sh"
        },
        "Short Description of the Vulnerability": "Multiple circuits call `Num2Bits(254)` and `Num2Bits(256)` when working with field elements of the BN-254 prime field. These templates do not enforce uniqueness of the bit decompositions, allowing malicious provers to bypass token expiration or revocation.",
        "Short Description of the Exploit": "Alice has a credential attesting to her identity. Mallory steals Alice’s device. Alice issues a revocation for her auth credential. Mallory modifies the witness generation to produce the wrong revocation nonce. Mallory uses the unrevoked credential to perform an action impersonating Alice.",
        "Proposed Mitigation": "Update the circuits to use `Num2Bits_strict()` instead of `Num2Bits(254)` or `Num2Bits(256)`.",
        "title": "Unsafe use of Num2Bits in multiple circuits"
    },
    {
        "Id": "reclaimprotocol/circom-chacha20/zksecurity-1",
        "Path": "dataset/circom/reclaimprotocol/circom-chacha20/zksecurity_unsound_left_rotation",
        "Project": "https://github.com/reclaimprotocol/circom-chacha20",
        "Commit": "ef9f5a5ad899d852740a26b30eabe5765673c71f",
        "Fix Commit": "e5e756375fc1fc8dc48667b00cdf38c79a0fdf50",
        "DSL": "Circom",
        "Vulnerability": "Under-Constrained",
        "Impact": "Soundness",
        "Root Cause": "Wrong Translation of Logic into Constraints",
        "Reproduced": true,
        "Location": {
            "Path": "circuits/generics.circom",
            "Function": "RotateLeft32Bits",
            "Line": "39-45"
        },
        "Source": {
            "Audit Report": {
                "Source Link": "https://github.com/zksecurity/zkbugs/blob/main/reports/documents/zksecurity-reclaimprotocol.pdf",
                "Bug ID": "#1 Unsound Left Rotation Gadget"
            }
        },
        "Commands": {
            "Setup Environment": "./zkbugs_setup.sh",
            "Reproduce": "./zkbugs_exploit.sh",
            "Compile and Preprocess": "./zkbugs_compile_setup.sh",
            "Positive Test": "./zkbugs_positive_test.sh",
            "Find Exploit": "./zkbugs_find_exploit.sh",
            "Clean": "./zkbugs_clean.sh"
        },
        "Short Description of the Vulnerability": "The `part1` and `part2` signals are not sufficiently constrained. One can arbitrarily set a value to `part1` or `part2` and find a value for the other signal to satisfy the constraint on line 45. This way you can get another `out` value for a given `in`.",
        "Short Description of the Exploit": "To exploit the vulnerability, one has to simply find a witness that produces a different value for `out` rather than the one produced by the witness generator. The sage script demonstrates how to find another witness that satisfies the constraints. Then, you simply need to produce a new proof.",
        "Proposed Mitigation": "The recommendation to fix this issue was to constrain `part1` (resp. `part2`) to be (resp. ) bit-sized values. For the concrete mitigation applied, check the commit of the fix.",
        "Similar Bugs": [
            "iden3/circomlib/kobi_gurkan_mimc_hash_assigned_but_not_constrained",
            "personaelabs/spartan-ecdsa/yacademy_input_signal_s_is_not_constrained_in_eff_ecdsa_circom"
        ],
        "title": "Unsound Left Rotation"
    },
    {
        "Id": "reclaimprotocol/circom-chacha20/zksecurity_Unsound_XOR_gadget",
        "Path": "dataset/circom/reclaimprotocol/circom-chacha20/zksecurity_Unsound_XOR_gadget",
        "Project": "https://github.com/reclaimprotocol/circom-chacha20",
        "Commit": "0xef9f5a5ad899d852740a26b30eabe5765673c71f",
        "Fix Commit": "ef9f5a5ad899d852740a26b30eabe5765673c71f",
        "DSL": "Circom",
        "Vulnerability": "Under-Constrained",
        "Impact": "Soundness",
        "Root Cause": "Wrong Translation of Logic into Constraints",
        "Reproduced": false,
        "Location": {
            "Path": "generics.circom",
            "Function": "XorWords",
            "Line": ""
        },
        "Source": {
            "Audit Report": {
                "Source Link": "https://github.com/zksecurity/zkbugs/blob/main/reports/documents/zksecurity-reclaimprotocol.pdf",
                "Bug ID": "Unsound XOR gadget"
            }
        },
        "Commands": {
            "Setup Environment": "",
            "Reproduce": "",
            "Compile and Preprocess": "",
            "Positive Test": "",
            "Find Exploit": "",
            "Clean": ""
        },
        "Short Description of the Vulnerability": "The \"Unsound XOR gadget\" bug found in the \"generics.circom\" of the Reclaim Protocol's ChaCha20 circuit relates to the incorrect implementation of the XOR operation on two M-bit value arrays. The bit constraints meant to ensure that the set bits were either 0 or 1 were commented out during the audit, compromising the security and validity of the operation. The XOR logic was supposed to decompose each operand into a series of checks on individual bits, but it failed to enforce that all bits must exactly represent the original values, allowing a malicious party to exploit the poorly constrained bit representation.",
        "Short Description of the Exploit": "",
        "Proposed Mitigation": "The recommended fix for the 'Unsound XOR gadget' is to enforce an XOR constraint (res = a + b - 2*ab) on each bit individually, ensuring that each bit is correctly constrained as 0 or 1.",
        "title": "Unsound XOR gadget"
    },
    {
        "Id": "reclaimprotocol/circom-chacha20/zksecurity_Potentially_Easy-to-Misuse_Interface",
        "Path": "dataset/circom/reclaimprotocol/circom-chacha20/zksecurity_Potentially_Easy_to_Misuse_Interface",
        "Project": "https://github.com/reclaimprotocol/circom-chacha20",
        "Commit": "0xef9f5a5ad899d852740a26b30eabe5765673c71f",
        "Fix Commit": "959fa1557225aed748a5d5ed468222c110faaef9",
        "DSL": "Circom",
        "Vulnerability": "Under-Constrained",
        "Impact": "Soundness",
        "Root Cause": "Missing Input Constraints",
        "Reproduced": false,
        "Location": {
            "Path": "chacha20.circom",
            "Function": "",
            "Line": ""
        },
        "Source": {
            "Audit Report": {
                "Source Link": "https://github.com/zksecurity/zkbugs/blob/main/reports/documents/zksecurity-reclaimprotocol.pdf",
                "Bug ID": "Potentially Easy-to-Misuse Interface"
            }
        },
        "Commands": {
            "Setup Environment": "",
            "Reproduce": "",
            "Compile and Preprocess": "",
            "Positive Test": "",
            "Find Exploit": "",
            "Clean": ""
        },
        "Short Description of the Vulnerability": "The ChaCha20 interface in the library can be easily misused because it allows users to provide their own key, nonce, starting counter, and plaintext/ciphertext inputs without any built-in constraints on these inputs. Typically, nonces are initialized in a standard manner, making it potentially safer to exclude user input for this component. The current design assumes all inputs are 32-bit, but does not enforce this, which increases the risk of misuse. Suggestions include renaming the interface to indicate its unchecked nature and adding documentation highlighting the importance of input constraints, or alternatively, designing an interface that enforces these constraints automatically.",
        "Short Description of the Exploit": "",
        "Proposed Mitigation": "To address the 'Potentially Easy-to-Misuse Interface' issue in the ChaCha20 circuit, the recommended fix includes adding warnings in the documentation about the necessity to constrain inputs as 32-bit values and considering renaming the interface to `ChaCha20Unsafe` or `ChaCha20Unchecked` to alert users about the need for careful handling. Additionally, an alternative interface should be provided that enforces checks on all inputs.",
        "title": "Potentially Easy-to-Misuse Interface"
    },
    {
        "Id": "reclaimprotocol/circom-chacha20/zksecurity_Unsound_Addition_Gadget",
        "Path": "dataset/circom/reclaimprotocol/circom-chacha20/zksecurity_Unsound_Addition_Gadget",
        "Project": "https://github.com/reclaimprotocol/circom-chacha20",
        "Commit": "0xef9f5a5ad899d852740a26b30eabe5765673c71f",
        "Fix Commit": "4551ca64c9fe536b7b9b7498a1feb1ecdc847474",
        "DSL": "Circom",
        "Vulnerability": "Under-Constrained",
        "Impact": "Soundness",
        "Root Cause": "Wrong Translation of Logic into Constraints",
        "Reproduced": false,
        "Location": {
            "Path": "generics.circom",
            "Function": "Add32Bits",
            "Line": ""
        },
        "Source": {
            "Audit Report": {
                "Source Link": "https://github.com/zksecurity/zkbugs/blob/main/reports/documents/zksecurity-reclaimprotocol.pdf",
                "Bug ID": "Unsound Addition Gadget"
            }
        },
        "Commands": {
            "Setup Environment": "",
            "Reproduce": "",
            "Compile and Preprocess": "",
            "Positive Test": "",
            "Find Exploit": "",
            "Clean": ""
        },
        "Short Description of the Vulnerability": "The `Add32Bits` gadget constrains the addition of two (assumed to be 32-bit) values to wrap around. In other words, if the addition of two 32-bit values overflows, the gadget removes the carry bit (the 33rd most-significant bit). To do that, the logic witnesses a carry bit, which is used to remove the carry from the result if set to 1. The problem is that the carry bit `tmp` is not constrained to be correctly computed. That is, there are two scenarios in which this function can be maliciously used: (1) If `a + b` are overowing (the result is 33 bits), then you can set `tmp=0` and the output will be 33 bits, (2) If `a + b` is not overflowing (the result is 32 bits), then you can set `tmp=1` and the output will underflow (it should be around the bit size of the circuit field). Both are problems if the output is not constrained to be 32 bits on the caller side, which seems to be the case.",
        "Short Description of the Exploit": "",
        "Proposed Mitigation": "In addition to fixing the issue, document the function to warn callers that they must be ensure that the two inputs are well-constrained to be 32-bit values.",
        "title": "Unsound Addition Gadget"
    },
    {
        "Id": "succinctlabs/telepathy-circuits/trailofbits-succinct-1",
        "Path": "dataset/circom/succinctlabs/telepathy-circuits/trailofbits_prover_can_lock_user_funds_by_including_ill-formed_bigints_in_public_key_commitment",
        "Project": "https://github.com/succinctlabs/telepathy-circuits",
        "Commit": "b0c839cef30c3c25ef41d1ad3000081784766934",
        "Fix Commit": "1a88e657932edc59b51e35095618f1e1a46ceef6",
        "DSL": "Circom",
        "Vulnerability": "Under-Constrained",
        "Impact": "Completeness",
        "Root Cause": "Unsafe Reuse of Circuit",
        "Reproduced": true,
        "Location": {
            "Path": "circuits/pairing/bls12_381_hash_to_G2",
            "Function": "SubgroupCheckG1WithValidX",
            "Line": "723-731"
        },
        "Source": {
            "Audit Report": {
                "Source Link": "https://github.com/zksecurity/zkbugs/blob/main/reports/documents/trailofbits-telepathy.pdf",
                "Bug ID": "1. Prover can lock user funds by including ill-formed BigInts in public key comitment"
            }
        },
        "Commands": {
            "Setup Environment": "./zkbugs_setup.sh",
            "Reproduce": "./zkbugs_exploit.sh",
            "Compile and Preprocess": "./zkbugs_compile_setup.sh",
            "Positive Test": "./zkbugs_positive_test.sh",
            "Find Exploit": "./zkbugs_find_exploit.sh",
            "Clean": "./zkbugs_clean.sh"
        },
        "Short Description of the Vulnerability": "The `Rotate()` template in rotate.circom fails to validate the format of BigInts in public keys. SubgroupCheckG1WithValidX assumes that its input is a properly formed BigInt, with all limbs less than 2**55. This property is not validated anywhere in the `Rotate()` template. It allows a malicious prover to manipulate public keys by inserting ill-formed BigInts, specifically by altering the y-coordinate of public keys. This manipulation can lock user funds by preventing future provers from generating valid proofs, as the circuit uses these malformed keys without proper validation. The exploit involves modifying the y coordinate in a public key to create an invalid commitment, which then updates the system's commitment state, potentially leading to incorrect or fraudulent operations.",
        "Short Description of the Exploit": "Subtract one from the most significant limb and add 2**55 to the second-most significant limb.",
        "Proposed Mitigation": "Use `Num2Bits()` template to verify that each limb of the `pubkeysBigIntY`, witness value is less than 2**55.",
        "title": "Prover can lock user funds by including ill-formed BigInts in public key commitment"
    },
    {
        "Id": "succinctlabs/telepathy-circuits/veridise-V-SUC-VUL-002-simplified",
        "Path": "dataset/circom/succinctlabs/telepathy-circuits/veridise_template_CoreVerifyPubkeyG1_does_not_perform_input_validation_simplified",
        "Project": "https://github.com/succinctlabs/telepathy-circuits",
        "Commit": "9c84fb0f38531718296d9b611f8bd6107f61a9b8",
        "Fix Commit": "b0c839cef30c3c25ef41d1ad3000081784766934",
        "DSL": "Circom",
        "Vulnerability": "Under-Constrained",
        "Impact": "Soundness",
        "Root Cause": "Unsafe Reuse of Circuit",
        "Reproduced": true,
        "Location": {
            "Path": "circuits/bls_signature.circom",
            "Function": "CoreVerifyPubkeyG1ToyExample",
            "Line": "77-95"
        },
        "Source": {
            "Audit Report": {
                "Source Link": "https://github.com/zksecurity/zkbugs/blob/main/reports/documents/veridise-telepathy.pdf",
                "Bug ID": "V-SUC-VUL-002: Template CoreVerifyPubkeyG1 does not perform input validation"
            }
        },
        "Commands": {
            "Setup Environment": "./zkbugs_setup.sh",
            "Reproduce": "./zkbugs_exploit.sh",
            "Compile and Preprocess": "./zkbugs_compile_setup.sh",
            "Positive Test": "./zkbugs_positive_test.sh",
            "Find Exploit": "./zkbugs_find_exploit.sh",
            "Clean": "./zkbugs_clean.sh"
        },
        "Short Description of the Vulnerability": "This bug is in the circom-pairing BLS signature verification logic. pubkey, signature and hash are divided into 7-entry chunks of 55-bit data, and each entry is checked against according entry in `p`. When calling `BigLessThan()`, the output isn't verified therefore attacker can manipulate the input so that it overflows p.",
        "Short Description of the Exploit": "The circuit had been simplified to demonstrate the bug, the attack idea is calculating a `delta` such that it makes the input overflow but still bounded by 2**55 - 1 to pass the range check inside `BigLessThan()`. In reality, attacker would bruteforce a special set of inputs satisfying a list of constraints. The details are explained in the PR comment.",
        "Proposed Mitigation": "In each iteration of the for loop, add a constraint `lt[idx].out === 1` to make sure the input is indeed bounded by `p`.",
        "title": "Template CoreVerifyPubkeyG1 does not perform input validation (Simplified)"
    },
    {
        "Id": "succinctlabs/telepathy-circuits/veridise-V-SUC-VUL-003",
        "Path": "dataset/circom/succinctlabs/telepathy-circuits/veridise_zero_padding_for_sha256_in_ExpandMessageXMD_is_vulnerable_to_an_overflow",
        "Project": "https://github.com/succinctlabs/telepathy-circuits",
        "Commit": "9c84fb0f38531718296d9b611f8bd6107f61a9b8",
        "Fix Commit": "b0c839cef30c3c25ef41d1ad3000081784766934",
        "DSL": "Circom",
        "Vulnerability": "Under-Constrained",
        "Impact": "Soundness",
        "Root Cause": "Arithmetic Field Issues",
        "Reproduced": true,
        "Location": {
            "Path": "circuits/hash_to_field.circom",
            "Function": "I2OSP",
            "Line": "3-23"
        },
        "Source": {
            "Audit Report": {
                "Source Link": "https://github.com/zksecurity/zkbugs/blob/main/reports/documents/veridise-telepathy.pdf",
                "Bug ID": "V-SUC-VUL-003: Zero Padding for Sha256 in ExpandMessageXMD is vulnerable to an overflow"
            }
        },
        "Commands": {
            "Setup Environment": "./zkbugs_setup.sh",
            "Reproduce": "./zkbugs_exploit.sh",
            "Compile and Preprocess": "./zkbugs_compile_setup.sh",
            "Positive Test": "./zkbugs_positive_test.sh",
            "Find Exploit": "./zkbugs_find_exploit.sh",
            "Clean": "./zkbugs_clean.sh"
        },
        "Short Description of the Vulnerability": "Template ExpandMessageXMD calls I2OSP(64) with `in` set to 0. In template I2OSP, numbers are represented in bigint format, a 64-byte chunk. This representation allows number much larger than scalar field modulus `p`, so attacker can compute `0 + k * p` and turn that into bigint representation and still pass the constraints.",
        "Short Description of the Exploit": "Compute `0 + p` and turn that into bigint format. Also keep track of the accumulator `acc[64]`.",
        "Proposed Mitigation": "Add assertion `assert(l < 31)` when using template I2OSP(l), so the largest possible number is 31 * 8 = 248 bit, which is less than scalar field modulus `p`.",
        "title": "Zero Padding for Sha256 in ExpandMessageXMD is vulnerable to an overflow"
    },
    {
        "Id": "succinctlabs/telepathy-circuits/trailofbits-succinct-2",
        "Path": "dataset/circom/succinctlabs/telepathy-circuits/trailofbits_prover_can_lock_user_funds_by_supplying_non-reduced_Y_values_to_G1BigIntToSignFlag",
        "Project": "https://github.com/succinctlabs/telepathy-circuits",
        "Commit": "b0c839cef30c3c25ef41d1ad3000081784766934",
        "Fix Commit": "1a88e657932edc59b51e35095618f1e1a46ceef6",
        "DSL": "Circom",
        "Vulnerability": "Under-Constrained",
        "Impact": "Completeness",
        "Root Cause": "Unsafe Reuse of Circuit",
        "Reproduced": true,
        "Location": {
            "Path": "circuits/bls.circom",
            "Function": "G1BigIntToSignFlag",
            "Line": "198-227"
        },
        "Source": {
            "Audit Report": {
                "Source Link": "https://github.com/zksecurity/zkbugs/blob/main/reports/documents/trailofbits-telepathy.pdf",
                "Bug ID": "2. Prover can lock user funds by supplying non-reduced Y values to G1BigIntToSignFlag"
            }
        },
        "Commands": {
            "Setup Environment": "./zkbugs_setup.sh",
            "Reproduce": "./zkbugs_exploit.sh",
            "Compile and Preprocess": "./zkbugs_compile_setup.sh",
            "Positive Test": "./zkbugs_positive_test.sh",
            "Find Exploit": "./zkbugs_find_exploit.sh",
            "Clean": "./zkbugs_clean.sh"
        },
        "Short Description of the Vulnerability": "`G1BigIntToSignFlag` fails to check if the y-coordinate is properly reduced mod p. This missing of range check allows malicious prover to lock user funds by supplying a non-reduced y-coordinate, which can be manipulated to have a positive sign when it should be negative. This manipulation can prevent future provers from generating valid proofs, effectively halting the LightClient and trapping user funds in the bridge.",
        "Short Description of the Exploit": "In detect.sage, we grab a 'positive' y-coordinate from a public key and turn it into 'negative' by negating it and mod p. We call this new value `y` and it has negative sign. Now we compute `2*p - y` and use it as input. This value is congruent to `-y mod p` so it is positive, but the circuit still considers it as negative. This fact can be observed in exploitable_witness.json: the second entry is 0, which represents negative sign.",
        "Proposed Mitigation": "Constrain the `pubkeysBigIntY` values to be less than `p` using `BigLessThan` template.",
        "title": "Prover can lock user funds by supplying non-reduced Y values to G1BigIntToSignFlag"
    },
    {
        "Id": "succinctlabs/telepathy-contracts",
        "Path": "dataset/circom/succinctlabs/telepathy-circuits/trailofbits_incorrect_handling_of_point_doubling_can_allow_signature_forgery",
        "Project": "https://github.com/succinctlabs/telepathy-circuits",
        "Commit": "b0c839cef30c3c25ef41d1ad3000081784766934",
        "Fix Commit": "",
        "DSL": "Circom",
        "Vulnerability": "Under-Constrained",
        "Impact": "Soundness",
        "Root Cause": "Unsafe Reuse of Circuit",
        "Reproduced": true,
        "Location": {
            "Path": "circuits/curve.circom",
            "Function": "EllipticCurveAddUnequal",
            "Line": "155-227"
        },
        "Source": {
            "Audit Report": {
                "Source Link": "https://github.com/zksecurity/zkbugs/blob/main/reports/documents/trailofbits-telepathy.pdf",
                "Bug ID": "3. Incorrect handling of point doubling can allow signature forgery"
            }
        },
        "Commands": {
            "Setup Environment": "./zkbugs_setup.sh",
            "Reproduce": "./zkbugs_exploit.sh",
            "Compile and Preprocess": "./zkbugs_compile_setup.sh",
            "Positive Test": "./zkbugs_positive_test.sh",
            "Find Exploit": "./zkbugs_find_exploit.sh",
            "Clean": "./zkbugs_clean.sh"
        },
        "Short Description of the Vulnerability": "`G1Add` calls `EllipticCurveAddUnequal`. The template `EllipticCurveAddUnequal` assumes input `a` and `b` are two unequal public keys but this is not checked. Attacker can use two same public keys to do sophisticated attacks. In such scenario, the constraint on output in `EllipticCurveAddUnequal` reduces to 0 = 0 so it is always true. In other words, attacker can do point doubling at a place where it is supposed to do point addition of two unequal EC points.",
        "Short Description of the Exploit": "We generate `A = aG`, `B = bG` and `C = (a+b)G`. We use `(a+b)G` for both inputs.",
        "Proposed Mitigation": "Change `G1Add` to use `EllipticCurveAdd`, which correctly handles equal inputs by checking and managing point doubling.",
        "title": "Incorrect handling of point doubling can allow signature forgery"
    },
    {
        "Id": "succinctlabs/telepathy-circuits/veridise-V-SUC-VUL-001",
        "Path": "dataset/circom/succinctlabs/telepathy-circuits/veridise_arrayxor_is_under_constrained",
        "Project": "https://github.com/succinctlabs/telepathy-circuits",
        "Commit": "9c84fb0f38531718296d9b611f8bd6107f61a9b8",
        "Fix Commit": "b0c839cef30c3c25ef41d1ad3000081784766934",
        "DSL": "Circom",
        "Vulnerability": "Under-Constrained",
        "Impact": "Soundness",
        "Root Cause": "Assigned but Unconstrained",
        "Reproduced": true,
        "Location": {
            "Path": "circuits/hash_to_field.circom",
            "Function": "ArrayXOR",
            "Line": "9"
        },
        "Source": {
            "Audit Report": {
                "Source Link": "https://github.com/zksecurity/zkbugs/blob/main/reports/documents/veridise-telepathy.pdf",
                "Bug ID": "V-SUC-VUL-001: ArrayXOR is under constrained"
            }
        },
        "Commands": {
            "Setup Environment": "./zkbugs_setup.sh",
            "Reproduce": "./zkbugs_exploit.sh",
            "Compile and Preprocess": "./zkbugs_compile_setup.sh",
            "Positive Test": "./zkbugs_positive_test.sh",
            "Find Exploit": "./zkbugs_find_exploit.sh",
            "Clean": "./zkbugs_clean.sh"
        },
        "Short Description of the Vulnerability": "out[i]` is assigned with `<--` but not constrained with `<==`, so it can be set to any value.",
        "Short Description of the Exploit": "Generate a correct witness first, then modify entry 2 to 5 to any field element.",
        "Proposed Mitigation": "Change the code to `out[i] <== a[i] ^ b[i]`.",
        "title": "ArrayXOR is under constrained"
    }
]